pub const MAX_PRIME_INDEX : usize = 54;
const MAX_PRIME : usize = 251;
const NOT_A_PRIME : usize = !1;
const MAX_EXPONENT : usize = 20;
pub const MAX_XI_TAU : usize = 10;
pub const PRIME_TO_INDEX_MAP : [usize; MAX_PRIME+1] = [
    !1, !1, 0, 1, !1, 2, !1, 3, !1, !1, !1, 4, !1, 5, !1, !1, !1, 6, !1, 
    7,  !1, !1, !1, 8, !1, !1, !1, !1, !1, 9, !1, 10, !1, !1, !1, !1, !1, 
    11, !1, !1, !1, 12, !1, 13, !1, !1, !1, 14, !1, !1, !1, !1, !1, 15, 
    !1, !1, !1, !1, !1, 16, !1, 17, !1, !1, !1, !1, !1, 18, !1, !1, !1, 
    19, !1, 20, !1, !1, !1, !1, !1, 21, !1, !1, !1, 22, !1, !1, !1, !1, 
    !1, 23, !1, !1, !1, !1, !1, !1, !1, 24, !1, !1, !1, 25, !1, 26, !1, 
    !1, !1, 27, !1, 28, !1, !1, !1, 29, !1, !1, !1, !1, !1, !1, !1, !1, 
    !1, !1, !1, !1, !1, 30, !1, !1, !1, 31, !1, !1, !1, !1, !1, 32, !1, 
    33, !1, !1, !1, !1, !1, !1, !1, !1, !1, 34, !1, 35, !1, !1, !1, !1, 
    !1, 36, !1, !1, !1, !1, !1, 37, !1, !1, !1, 38, !1, !1, !1, !1, !1, 
    39, !1, !1, !1, !1, !1, 40, !1, 41, !1, !1, !1, !1, !1, !1, !1, !1, 
    !1, 42, !1, 43, !1, !1, !1, 44, !1, 45, !1, !1, !1, !1, !1, !1, !1, 
    !1, !1, !1, !1, 46, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, 47, 
    !1, !1, !1, 48, !1, 49, !1, !1, !1, 50, !1, !1, !1, !1, !1, 51, !1, 
    52, !1, !1, !1, !1, !1, !1, !1, !1, !1, 53 //, !1, !1, !1, !1
];


// Mathematica: 
// "[\n    " <> # <> "\n]" &[
//  StringJoin @@ 
//   StringReplace[
//    ToString /@ 
//     Riffle[Map[If[# > 2^31, 0, #] &, 
//       Function[p, 
//         PadRight[PowerMod[#, -1, p] & /@ Range[p - 1], 
//          Prime[8] - 1]] /@ Prime[Range[8]], {2}], ",\n    "], {"{" -> 
//      "[", "}" -> "]"}]]
static INVERSE_TABLE : [[u32; 19]; 8] = [
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 3, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 4, 5, 2, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 6, 4, 3, 9, 2, 8, 7, 5, 10, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 7, 9, 10, 8, 11, 2, 5, 3, 4, 6, 12, 0, 0, 0, 0, 0, 0],
    [0, 1, 9, 6, 13, 7, 3, 5, 15, 2, 12, 14, 10, 4, 11, 8, 16, 0, 0],
    [0, 1, 10, 13, 5, 4, 16, 11, 12, 17, 2, 7, 8, 3, 15, 14, 6, 9, 18]
];


// Generated by Mathematica:
// "[\n    " <> # <> "\n]" &[
//  StringJoin @@ 
//   StringReplace[
//    ToString /@ 
//     Riffle[Map[If[# > 2^31, 0, #] &, 
//       Function[p, Function[k, (p^k - 1)/(p - 1)] /@ Range[10]] /@ 
//        Prime[Range[8]], {2}], ",\n    "], {"{" -> "[", "}" -> "]"}]]
static XI_DEGREES : [[i32; 10]; 8] = [
    [1, 3, 7, 15, 31, 63, 127, 255, 511, 1023],
    [1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524],
    [1, 6, 31, 156, 781, 3906, 19531, 97656, 488281, 2441406],
    [1, 8, 57, 400, 2801, 19608, 137257, 960800, 6725601, 47079208],
    [1, 12, 133, 1464, 16105, 177156, 1948717, 21435888, 235794769, 0],
    [1, 14, 183, 2380, 30941, 402234, 5229043, 67977560, 883708281, 0],
    [1, 18, 307, 5220, 88741, 1508598, 25646167, 435984840, 0, 0],
    [1, 20, 381, 7240, 137561, 2613660, 49659541, 943531280, 0, 0]
];

// Generated by Mathematica:
// "[\n    " <> # <> "\n]" &[
//  StringJoin @@ 
//   StringReplace[
//    ToString /@ 
//     Riffle[Map[If[# > 2^31, 0, #] &, 
//       Function[p, Function[k, 2 p^k - 1] /@ Range[10]] /@ Prime[Range[8]], {2}], ",\n    "], {"{" -> "[", "}" -> "]"}]]
static TAU_DEGREES : [[i32; 10]; 8] = [
    [1, 3, 7, 15, 31, 63, 127, 255, 511, 1023],
    [1, 5, 17, 53, 161, 485, 1457, 4373, 13121, 39365],
    [1, 9, 49, 249, 1249, 6249, 31249, 156249, 781249, 3906249],
    [1, 13, 97, 685, 4801, 33613, 235297, 1647085, 11529601, 80707213],
    [1, 21, 241, 2661, 29281, 322101, 3543121, 38974341, 428717761, 0],
    [1, 25, 337, 4393, 57121, 742585, 9653617, 125497033, 1631461441, 0],
    [1, 33, 577, 9825, 167041, 2839713, 48275137, 820677345, 0, 0],
    [1, 37, 721, 13717, 260641, 4952197, 94091761, 1787743477, 0, 0]
];

pub fn is_valid_prime(p : u32) -> bool {
    (p as usize) < MAX_PRIME && PRIME_TO_INDEX_MAP[p as usize] != NOT_A_PRIME
}

// Uses a the lookup table we initialized.
pub fn inverse(p : u32, k : u32) -> u32{
    assert!(is_valid_prime(p));
    let result = INVERSE_TABLE[PRIME_TO_INDEX_MAP[p as usize]][k as usize];
    assert!(result != 0);
    result
}

pub fn minus_one_to_the_n(p : u32, i : u32) -> u32 {
    if i % 2 == 0 { 1 } else { p - 1 }
}


// Makes a lookup table for n choose k when n and k are both less than p.
// Lucas's theorem reduces general binomial coefficients to this case.

// This is a table lookup, n, k < p.
fn direct_binomial(p : u32, n : u32, k : u32) -> u32{
    assert!(is_valid_prime(p));
    BINOMIAL_TABLE[PRIME_TO_INDEX_MAP[p as usize]][n as usize][k as usize]
}


/// Computes b^e.
pub fn integer_power(b : u32, e : u32) -> u32 {
    let mut b = b;
    let mut e = e;
    let mut result = 1u32;
    while e > 0 {
        if e&1 == 1 {
            result *= b;
        }
        b *= b;
        e >>= 1;
    }
    result
}

/// Compute b^e mod p.
/// We use this for computing modulo inverses.
pub fn power_mod(p : u32, b : u32, e : u32) -> u32{
    let mut b = b;
    let mut e = e;
    let mut result = 1u32;
//      b is b^{2^i} mod p
//      if the current bit of e is odd, mutliply b^{2^i} mod p into r.
    while e > 0 {
        if (e&1) == 1 {
            result = (result*b)%p;
        }
        b = (b*b)%p;
        e >>= 1;
    }
    result
}

// Discrete log base p of n.
pub fn logp(p : u32, mut n : u32) -> u32 {
    let mut result = 0u32;
    while n > 0 {
        n /= p;
        result += 1;
    }
    result
}

/**
 * Expand n base p and write the result into buffer result.
 * Result has to have length greater than logp(p, n) or we'll have a buffer overflow.
 */
fn basep_expansion(result : &mut[u32], p : u32, mut n : u32) -> &mut[u32] {
    let mut i = 0usize;
    while n > 0 {
        result[i] = n % p;
        i += 1;
        n /= p;
    }
    result
}


//Multinomial coefficient of the list l
fn multinomial2(l : &[u32]) -> u32 {
    let mut bit_or = 0u32;
    let mut sum = 0u32;
    for e in l {
        sum += e;
        bit_or |= e;
//        if(bit_or < sum){
//            return 0;
//        }
    }
    if bit_or == sum { 1 } else { 0 }
}

//Mod 2 binomial coefficient n choose k
fn binomial2(n : i32, k : i32) -> u32 {
    if n < k {
        0
    } else if (n-k) & k == 0 {
        1
    } else {
        0
    }
}

//Mod p multinomial coefficient of l. If p is 2, more efficient to use Multinomial2.
//This uses Lucas's theorem to reduce to n choose k for n, k < p.
// There is some cleaning up to be done here about the arrays. Suppress clippy for now
#[allow(clippy::needless_range_loop)]
fn multinomial_odd(p : u32, l : &[u32]) -> u32{
    let mut total = 0u32;
    for e in l {
        total += e;
    }
    let mut answer = 1u32;
    let mut total_expansion : [u32 ; MAX_EXPONENT] = [0; MAX_EXPONENT];
    let base_p_expansion_length = logp(p, total) as usize;
    basep_expansion(&mut total_expansion, p, total);
    let mut l_expansions : [[u32; MAX_EXPONENT];MAX_XI_TAU] = [[0;MAX_EXPONENT];MAX_XI_TAU];
    for i in 0..l.len() {
        basep_expansion(&mut l_expansions[i], p,  l[i]);
    }
    for index in 0 .. base_p_expansion_length {
        let mut multi = 1u32;
        let mut partial_sum = 0u32;
        for i in 0 .. l.len() {
            partial_sum += l_expansions[i][index];
            if partial_sum > total_expansion[index] {
                return 0
            }
            multi *= direct_binomial(p, partial_sum, l_expansions[i][index]);
            multi %= p;
        }
        answer = (answer * multi) % p;
    }
    answer
}

//Mod p binomial coefficient n choose k. If p is 2, more efficient to use Binomial2.
fn binomial_odd(p : u32, n : i32, k : i32) -> u32 {
    if n < k || k < 0 {
        return 0;
    }
    let l : [u32 ; 2] = [(n-k) as u32, k as u32];
    multinomial_odd(p, &l)
}

//Dispatch to Multinomial2 or MultinomialOdd
pub fn multinomial(p : u32, l : &[u32]) -> u32 {
    if p == 2{
        multinomial2(l)
    } else {
        multinomial_odd(p, l)
    }
}

//Dispatch to Binomial2 or BinomialOdd
pub fn binomial(p : u32, n : i32, k : i32) -> u32 {
    if p == 2{
        binomial2(n, k)
    } else {
        binomial_odd(p, n, k)
    }
}

pub fn adem_relation_coefficient(p : u32, x : u32, y : u32, j : u32, e1 : u32, e2 : u32) -> u32{
    let pi32 = p as i32;
    let x = x as i32;
    let y = y as i32;
    let j = j as i32;
    let e1 = e1 as i32;
    let e2 = e2 as i32;
    let mut c = binomial(p, (y-j) * (pi32-1) + e1 - 1, x - pi32*j - e2);
    if c == 0 { 
        return 0; 
    }
    c *= minus_one_to_the_n(p, ((x + j) + e2) as u32);
    c % p
}

pub fn inadmissible_pairs(p : u32, generic : bool, degree : i32) -> Vec<(u32, u32, u32)> {
    let degree = degree as u32;
    let q = if generic { 2*p-2 } else { 1 };
    // (i, b, j) means P^i P^j if b = 0, or P^i b P^j if b = 1.
    let mut inadmissible_pairs = Vec::new();

    // Since |P^i| is always a multiple of q, we have a relation only if degree = 0 or 1 mod q.
    // If it is 0, then there is no Bockstein. Otherwise, there is.
    if degree % q == 0 {
        let degq = degree/q;
        // We want P^i P^j to be inadmissible, so i < p * j. This translates to
        // i < p * degq /(p + 1). Since Rust automatically rounds *down*, but we want to round
        // up instead, we use i < (p * degq + p)/(p + 1).
        for i in 1 .. (p * degq + p) / (p + 1) {
            inadmissible_pairs.push((i, 0, degq - i));
        }
    } else if degree % q == 1 {
        let degq = degree/q; // Since we round down, this is actually (degree - 1)/q
        // We want P^i b P^j to be inadmissible, so i < p * j + 1. This translates to
        // i < (p * degq + 1)/(p + 1). Since Rust automatically rounds *down*, but we want to round
        // up instead, we use i < (p * degq + p + 1)/(p + 1).
        for i in 1 .. (p * degq + p + 1) / (p + 1) {
            inadmissible_pairs.push((i, 1, degq - i));
        }
    }
    inadmissible_pairs
}

pub fn tau_degrees(p : u32) -> &'static [i32] {
    &TAU_DEGREES[PRIME_TO_INDEX_MAP[p as usize]]
}

pub fn xi_degrees(p : u32) -> &'static [i32] {
    &XI_DEGREES[PRIME_TO_INDEX_MAP[p as usize]]
}


#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    // use super::*;

    // #[test]
    // fn test_basep_expansion(){

    //     tables := []struct {
    //         n int
    //         p int
    //         output []int
    //     }{
    //         {8,  3, []int {2, 2}},
    //         {33, 5, []int {3, 1, 1}},
    //     }
    //     for _, table := range tables {
    //         output := basepExpansion(table.n, table.p, 0)
    //         if !eqListsQ(output, table.output) {
    //             t.Errorf("Ran basepExpansion(%v,%v) expected %v got %v", table.n, table.p, table.output, output)
    //         }
    //     }
    // }

    // #[test]
    // fn direct_binomial(t *testing.T) {
    //     tables := []struct {
    //         n int
    //         k int
    //         p int
    //         output int
    //     }{
    //         {21, 2, 23, 210},
    //         {13, 9, 23, 715},
    //         {12, 8, 23, 495},
    //         {13, 8, 23, 1287},
    //         {14, 8, 23, 3003},
    //         {14, 9, 23, 2002},
    //         {15, 5, 23, 3003},
    //         {15, 8, 23, 6435},  
    //         {15, 9, 23, 5005},
    //         {16, 9, 23, 11440},
    //     }
    //     for _, table := range tables {
    //         output := direct_binomial(table.n, table.k, table.p)
    //         if output != table.output  % table.p {
    //             t.Errorf("Ran directBinomial(%v,%v) expected %v, got %v", table.n, table.k, table.output % table.p, output)
    //         }
    //     }    
    // }

    // func TestMultinomial2(t *testing.T) {
    //     tables := []struct {
    //         l []int
    //         output int
    //     }{
    //         {[]int {1, 2}, 1},
    //         {[]int {1, 3}, 0},
    //         {[]int {1, 4}, 1},
    //         {[]int {2, 4}, 1},
    //         {[]int {1, 5}, 0},
    //         {[]int {2, 5}, 1},
    //         {[]int {2, 6}, 0},
    //         {[]int {2, 4, 8}, 1},
    //     }
    //     for _, table := range tables {
    //         output := Multinomial2(table.l)
    //         if output != table.output {
    //             t.Errorf("Ran Multinomial2(%v) expected %v, got %v", table.l, table.output, output)
    //         }
    //     }        
    // }
        
    // func TestBinomial2(t *testing.T) {
    //     tables := []struct {
    //         n int
    //         k int
    //         output int
    //     }{
    //         {4, 2, 0},
    //         {72, 46, 0},
    //         {82, 66, 1},
    //         {165, 132, 1},
    //         {169, 140, 0},
    //     }
    //     for _, table := range tables {
    //         output := Binomial2(table.n, table.k)
    //         if output != table.output {
    //             t.Errorf("Ran Binomial2(%v,%v) expected %v, got %v", table.n, table.k, table.output, output)
    //         }
    //     }        
    // }


    // func TestMultinomialOdd(t *testing.T) {
    //     tables := []struct {
    //         l []int
    //         p int
    //         output int
    //     }{
    //         {[]int {1090, 730}, 3, 1},
    //         {[]int {108054, 758}, 23, 18},
    //         {[]int {3, 2}, 7, 3},
    //     }
    //     for _, table := range tables {
    //         output := MultinomialOdd(table.l, table.p)
    //         if output != table.output {
    //             t.Errorf("Ran MultinomialOdd(%v, %v) expected %v, got %v", table.l, table.p, table.output, output)
    //         }
    //     }        
    // }
    // //
    // func TestBinomialOdd(t *testing.T) {
    
    // }

    // #[test]
    // func TestXiDegrees(t *testing.T) {
    //     let tables : []struct {
    //         n int
    //         p int
    //         output []int
    //     }{
    //         {17,   2, []int{1, 3, 7, 15}},
    //         {17,   3, []int{1, 4, 13}},
    //         {400, 17, []int{1, 18, 307}},
    //     }
        
    //     for _, table := range tables {
    //         output := XiDegrees(table.n, table.p)
    //         if !eqListsQ(output, table.output) {
    //             t.Errorf("Ran XiDegrees(%v, %v) expected %v, got %v", table.n, table.p, table.output, output)
    //         }
    //     }   
    // }
}

// Mathematica:
// StringReplace[
//  "[\n    " <> # <> "\n]" &[
//   StringJoin @@ 
//    StringReplace[
//     ToString /@ 
//      Riffle[Function[p, 
//         PadRight[
//          PadRight[#, Prime[8]] & /@ 
//           Table[Mod[Binomial[n, k], p], {n, 0, p - 1}, {k, 0, p - 1}],
//           Prime[8], {Table[0, {Prime[8]}]}]] /@ Prime[Range[8]], 
//       ",\n    "], {"{" -> "[", "}" -> "]"}]], "], " -> "],\n     "]
static BINOMIAL_TABLE : [[[u32; 19]; 19]; 8] = [
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 4, 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 4, 6, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 5, 3, 3, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 6, 1, 6, 1, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 4, 6, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 5, 10, 10, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 6, 4, 9, 4, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 7, 10, 2, 2, 10, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 8, 6, 1, 4, 1, 6, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 9, 3, 7, 5, 5, 7, 3, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 4, 6, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 5, 10, 10, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 6, 2, 7, 2, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 7, 8, 9, 9, 8, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 8, 2, 4, 5, 4, 2, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 9, 10, 6, 9, 9, 6, 10, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 10, 6, 3, 2, 5, 2, 3, 6, 10, 1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 11, 3, 9, 5, 7, 7, 5, 9, 3, 11, 1, 0, 0, 0, 0, 0, 0, 0],
     [1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 4, 6, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 5, 10, 10, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 6, 15, 3, 15, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 7, 4, 1, 1, 4, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 8, 11, 5, 2, 5, 11, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 9, 2, 16, 7, 7, 16, 2, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 10, 11, 1, 6, 14, 6, 1, 11, 10, 1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 11, 4, 12, 7, 3, 3, 7, 12, 4, 11, 1, 0, 0, 0, 0, 0, 0, 0],
     [1, 12, 15, 16, 2, 10, 6, 10, 2, 16, 15, 12, 1, 0, 0, 0, 0, 0, 0],
     [1, 13, 10, 14, 1, 12, 16, 16, 12, 1, 14, 10, 13, 1, 0, 0, 0, 0, 0],
     [1, 14, 6, 7, 15, 13, 11, 15, 11, 13, 15, 7, 6, 14, 1, 0, 0, 0, 0],
     [1, 15, 3, 13, 5, 11, 7, 9, 9, 7, 11, 5, 13, 3, 15, 1, 0, 0, 0],
     [1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
    [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 4, 6, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 5, 10, 10, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 6, 15, 1, 15, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 7, 2, 16, 16, 2, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 8, 9, 18, 13, 18, 9, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 9, 17, 8, 12, 12, 8, 17, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 10, 7, 6, 1, 5, 1, 6, 7, 10, 1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 11, 17, 13, 7, 6, 6, 7, 13, 17, 11, 1, 0, 0, 0, 0, 0, 0, 0],
     [1, 12, 9, 11, 1, 13, 12, 13, 1, 11, 9, 12, 1, 0, 0, 0, 0, 0, 0],
     [1, 13, 2, 1, 12, 14, 6, 6, 14, 12, 1, 2, 13, 1, 0, 0, 0, 0, 0],
     [1, 14, 15, 3, 13, 7, 1, 12, 1, 7, 13, 3, 15, 14, 1, 0, 0, 0, 0],
     [1, 15, 10, 18, 16, 1, 8, 13, 13, 8, 1, 16, 18, 10, 15, 1, 0, 0, 0],
     [1, 16, 6, 9, 15, 17, 9, 2, 7, 2, 9, 17, 15, 9, 6, 16, 1, 0, 0],
     [1, 17, 3, 15, 5, 13, 7, 11, 9, 9, 11, 7, 13, 5, 15, 3, 17, 1, 0],
     [1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1]]
];
