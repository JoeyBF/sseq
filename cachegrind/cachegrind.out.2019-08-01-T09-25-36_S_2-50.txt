--------------------------------------------------------------------------------
Profile data file 'cachegrind/cachegrind.out.2019-08-01-T09-25-36_S_2-50' (creator: callgrind-3.13.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 1128635642
Trigger: Program termination
Profiled target:  target/release/rust_ext S_2 50 (PID 20741, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
           Ir 
--------------------------------------------------------------------------------
4,961,490,740  PROGRAM TOTALS

--------------------------------------------------------------------------------
           Ir  file:function
--------------------------------------------------------------------------------
1,848,128,936  src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_entry [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
  365,768,901  src/fp_vector.rs:rust_ext::fp_vector::FpVector::add [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
  295,666,869  src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
  215,900,353  src/memory.rs:rust_ext::fp_vector::FpVector::add
  186,945,531  src/memory.rs:rust_ext::matrix::Matrix::row_reduce
  163,045,131  src/matrix.rs:rust_ext::matrix::Matrix::row_reduce [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
  160,706,864  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::fp_vector::FpVector::get_entry
  160,706,864  src/memory.rs:rust_ext::fp_vector::FpVector::get_entry
  141,545,031  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/hash/sip.rs:<std::collections::hash::map::DefaultHasher as core::hash::Hasher>::write
  118,904,954  src/fp_vector.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
  109,558,147  src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_offset [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   84,562,827  /build/glibc-OTsEL5/glibc-2.27/malloc/malloc.c:free [/lib/x86_64-linux-gnu/libc-2.27.so]
   62,586,575  src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2 [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   48,247,650  /build/glibc-OTsEL5/glibc-2.27/malloc/malloc.c:malloc [/lib/x86_64-linux-gnu/libc-2.27.so]
   40,489,560  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/num/mod.rs:std::collections::hash::map::HashMap<K,V,S>::get
   37,494,916  src/fp_vector.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
   35,757,973  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/iter/range.rs:rust_ext::fp_vector::FpVector::add
   35,590,950  src/fp_vector.rs:rust_ext::fp_vector::FpVector::reduce_limbs [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   34,029,799  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/iter/range.rs:rust_ext::matrix::Matrix::row_reduce
   33,876,881  src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   33,206,053  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/cmp.rs:rust_ext::fp_vector::FpVector::add
   32,391,648  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/hash/sip.rs:std::collections::hash::map::HashMap<K,V,S>::get
   28,984,760  src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2 [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   28,066,688  src/fp_vector.rs:rust_ext::fp_vector::FpVector::set_entry [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   27,994,313  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/num/mod.rs:<std::collections::hash::map::DefaultHasher as core::hash::Hasher>::write
   26,318,214  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libstd/collections/hash/map.rs:std::collections::hash::map::HashMap<K,V,S>::get [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   25,897,826  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/cmp.rs:rust_ext::matrix::Matrix::row_reduce
   25,159,347  /build/glibc-OTsEL5/glibc-2.27/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe [/lib/x86_64-linux-gnu/libc-2.27.so]
   25,118,742  /build/glibc-OTsEL5/glibc-2.27/malloc/malloc.c:_int_malloc [/lib/x86_64-linux-gnu/libc-2.27.so]
   23,174,616  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::fp_vector::FpVector::get_limb_mask
   21,771,456  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::fp_vector::FpVector::add
   21,294,004  /cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.4.0/src/raw/mod.rs:std::collections::hash::map::HashMap<K,V,S>::get
   21,189,792  src/free_module.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::act_on_basis [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   19,381,955  src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   19,232,541  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/hash/mod.rs:std::collections::hash::map::HashMap<K,V,S>::get
   16,854,658  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
   16,107,648  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements
   15,995,971  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/num/mod.rs:rust_ext::matrix::Matrix::row_reduce
   12,633,184  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
   11,155,793  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libstd/collections/hash/map.rs:<std::collections::hash::map::DefaultHasher as core::hash::Hasher>::write [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
   10,167,576  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:std::collections::hash::map::HashMap<K,V,S>::get
    9,936,066  src/fp_vector.rs:rust_ext::matrix::Matrix::row_reduce
    9,611,701  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/intrinsics.rs:<std::collections::hash::map::DefaultHasher as core::hash::Hasher>::write
    9,110,151  src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    8,671,870  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    8,513,222  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements
    8,315,432  src/fp_vector.rs:rust_ext::module::Module::act
    8,203,866  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
    8,186,108  /cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.4.0/src/raw/bitmask.rs:std::collections::hash::map::HashMap<K,V,S>::get
    7,989,036  src/fp_vector.rs:rust_ext::fp_vector::FpVector::new [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    7,940,586  src/module.rs:rust_ext::module::Module::act [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    6,662,320  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/num/mod.rs:rust_ext::fp_vector::FpVector::add
    6,435,894  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements
    6,408,508  src/fp_vector.rs:rust_ext::fp_vector::FpVector::assign [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    6,163,464  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
    6,085,779  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/cmp.rs:<std::collections::hash::map::DefaultHasher as core::hash::Hasher>::write
    5,655,537  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:rust_ext::fp_vector::FpVector::new
    5,552,603  /build/glibc-OTsEL5/glibc-2.27/malloc/malloc.c:malloc_consolidate [/lib/x86_64-linux-gnu/libc-2.27.so]
    5,541,292  src/free_module_homomorphism.rs:rust_ext::free_module_homomorphism::FreeModuleHomomorphism::get_matrix_with_table [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    5,161,616  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements
    5,091,346  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/ptr.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    5,009,452  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c//src/libstd/sys/unix/alloc.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    4,278,511  /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    4,251,606  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    4,074,960  src/free_module.rs:rust_ext::free_module::FreeModule::operation_generator_to_index [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    4,048,956  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index
    3,897,057  src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::generate_multiplication_table [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    3,803,296  /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements
    3,704,607  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/iter/range.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index
    3,669,524  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
    3,639,804  src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    3,044,092  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs:std::collections::hash::map::HashMap<K,V,S>::get
    2,988,304  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::act_on_basis
    2,810,451  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/ptr.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements
    2,808,960  src/fp_vector.rs:rust_ext::adem_algebra::AdemAlgebra::generate_multiplication_table
    2,516,880  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/intrinsics.rs:rust_ext::matrix::Matrix::row_reduce
    2,417,295  /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
    2,173,312  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/sync/atomic.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements
    2,158,976  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::fp_vector::FpVector::set_entry
    2,158,976  src/memory.rs:rust_ext::fp_vector::FpVector::set_entry
    2,139,761  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
    2,129,440  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/ptr.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
    2,055,034  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index
    2,055,034  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index
    2,028,572  src/adem_algebra.rs:std::collections::hash::map::HashMap<K,V,S>::get
    2,028,572  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:std::collections::hash::map::HashMap<K,V,S>::get
    2,024,478  /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index
    2,024,478  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index
    2,024,478  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/sync/atomic.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index
    2,024,478  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:std::collections::hash::map::HashMap<K,V,S>::get
    1,901,648  src/fp_vector.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::act_on_basis
    1,831,883  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/iter/range.rs:rust_ext::fp_vector::FpVector::new
    1,819,902  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension
    1,629,984  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:rust_ext::free_module::FreeModule::operation_generator_to_index
    1,629,984  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::act_on_basis
    1,575,435  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/ptr.rs:rust_ext::matrix::Matrix::new
    1,562,935  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/cmp.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index
    1,486,323  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/num/mod.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    1,422,026  /build/glibc-OTsEL5/glibc-2.27/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms [/lib/x86_64-linux-gnu/libc-2.27.so]
    1,384,284  src/free_module_homomorphism.rs:rust_ext::free_module_homomorphism::FreeModuleHomomorphism::get_output [/mnt/c/Users/Hood/Documents/programming/rust_ext/target/release/rust_ext]
    1,358,320  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs:rust_ext::free_module::FreeModule::operation_generator_to_index
    1,358,320  /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::act_on_basis
    1,317,423  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/cmp.rs:rust_ext::fp_vector::FpVector::new
    1,286,403  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:rust_ext::main
    1,279,094  src/free_module.rs:rust_ext::main
    1,278,960  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/sync/atomic.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    1,268,242  src/memory.rs:rust_ext::fp_vector::FpVector::assign
    1,258,440  src/fp_vector.rs:rust_ext::free_module_homomorphism::FreeModuleHomomorphism::get_matrix_with_table
    1,213,268  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension
    1,213,268  /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension
    1,213,268  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/sync/atomic.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension
    1,188,551  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/ptr.rs:rust_ext::fp_vector::FpVector::new
    1,137,950  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c//src/libstd/sys/unix/alloc.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2
    1,086,656  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/sync/atomic.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::act_on_basis
    1,086,656  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:rust_ext::free_module::FreeModule::operation_generator_to_index
    1,077,260  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/iter/range.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2
    1,027,517  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index
    1,024,157  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs:rust_ext::adem_algebra::AdemAlgebra::generate_multiplication_table
    1,013,714  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/intrinsics.rs:std::collections::hash::map::HashMap<K,V,S>::get
    1,012,239  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index
    1,012,239  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs:std::collections::hash::map::HashMap<K,V,S>::get
    1,012,239  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index

--------------------------------------------------------------------------------
-- Auto-annotated source: src/fp_vector.rs
--------------------------------------------------------------------------------
         Ir 

-- line 21 ----------------------------------------
          .  // But for 2 it should be 1.
          .  static BIT_LENGHTS : [usize; MAX_PRIME_INDEX] = [
          .       1, 3, 5, 6, 7, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 12, 13,     
          .       13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15,    
          .       15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16 
          .  ];
          .  
          .  fn get_bit_length(p : u32) -> usize {
282,980,328      BIT_LENGHTS[PRIME_TO_INDEX_MAP[p as usize]]
          .  }
          .  
          .  // This is 2^bitlength - 1.
          .  // Generated with Mathematica:
          .  //     2^bitlengths-1
          .  static BITMASKS : [u32; MAX_PRIME_INDEX] = [
          .      1, 7, 31, 63, 127, 255, 511, 511, 511, 1023, 1023, 2047, 2047, 2047, 
          .      4095, 4095, 4095, 4095, 8191, 8191, 8191, 8191, 8191, 8191, 16383, 
          .      16383, 16383, 16383, 16383, 16383, 16383, 32767, 32767, 32767, 32767, 
          .      32767, 32767, 32767, 32767, 32767, 32767, 32767, 65535, 65535, 65535,
          .      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535
          .  ];
          .  
          .  fn get_bitmask(p : u32) -> u64{
162,865,840      BITMASKS[PRIME_TO_INDEX_MAP[p as usize]] as u64
          .  }
          .  
          .  // This is floor(64/bitlength).
          .  // Generated with Mathematica:
          .  //      Floor[64/bitlengths]
          .  static ENTRIES_PER_64_BITS : [usize;MAX_PRIME_INDEX] = [
          .      64, 21, 12, 10, 9, 8, 7, 7, 7, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4,  
          .      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
          .      4, 4, 4, 4, 4, 4, 4, 4, 4, 4
          .  ];
          .  
          .  fn get_entries_per_64_bits(p : u32) -> usize {
 16,278,401      return ENTRIES_PER_64_BITS[PRIME_TO_INDEX_MAP[p as usize]];   
          .  }
          .  
          .  struct LimbBitIndexPair {
          .      limb : usize,
          .      bit_index : usize
          .  }
          .  
          .  static mut LIMB_BIT_INDEX_TABLE : [Option<Vec<LimbBitIndexPair>>; MAX_PRIME_INDEX] = [
-- line 65 ----------------------------------------
-- line 84 ----------------------------------------
          .  
          .  /**
          .   * Called by initializePrime
          .   * This table tells us which limb and which bitfield of that limb to look for a given index of
          .   * the vector in.
          .   */
          .  pub fn initialize_limb_bit_index_table(p : u32){
          .      unsafe{
          7          LIMB_BIT_INDEX_ONCE_TABLE[PRIME_TO_INDEX_MAP[p as usize]].call_once(||{
          4              println!("initialize {}", p);
      3,333  => /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c//src/libstd/io/stdio.rs:std::io::stdio::_print (1x)
          2              let entries_per_limb = get_entries_per_64_bits(p);
          .              let bit_length = get_bit_length(p);
          .              let mut table : Vec<LimbBitIndexPair> = Vec::with_capacity(MAX_DIMENSION);
          .              for i in 0 .. MAX_DIMENSION {
          .                  table.push(LimbBitIndexPair{
          .                      limb : i/entries_per_limb,
    590,000                      bit_index : (i % entries_per_limb) * bit_length,
          .                  })
          .              }
         21              LIMB_BIT_INDEX_TABLE[PRIME_TO_INDEX_MAP[p as usize]] = Some(table);
          .          });
          .      }
          .  }
          .  
          .  fn get_limb_bit_index_pair(p : u32, idx : usize) -> &'static LimbBitIndexPair {
 11,617,898      let prime_idx = PRIME_TO_INDEX_MAP[p as usize];
          .      debug_assert!(valid_prime_q(p));
          .      debug_assert!(idx < MAX_DIMENSION);
          .      unsafe {
167,345,093          let table = &LIMB_BIT_INDEX_TABLE[prime_idx];
          .          return table.as_ref().unwrap().get_unchecked(idx);
          .      }
          .  }
          .  
          .  struct VectorContainer {
          .      dimension : usize, // These have to match the definition of Vector in FpVector.h
          .      offset : usize,
          .      slice_start : usize,
-- line 121 ----------------------------------------
-- line 137 ----------------------------------------
          .  }
          .  
          .  pub struct VectorContainer5 {
          .      vector_container : VectorContainer
          .  }
          .  
          .  impl VectorContainer2 {
          .      fn add_limb(limb_a : u64, limb_b : u64, _coeff : u32) -> u64 {
  2,714,113          return limb_a ^ limb_b;
          .      }
          .  
          .      fn reduce_limbs(&mut self, _start_limb : usize, _end_limb : usize){}
          .  }
          .  
          .  impl VectorContainer3 {
          .      fn add_limb(limb_a : u64, limb_b : u64, coeff : u32) -> u64 {
          .          return limb_a + (coeff as u64) * limb_b;
-- line 153 ----------------------------------------
-- line 222 ----------------------------------------
          .      Vector3(VectorContainer3),
          .      Vector5(VectorContainer5),
          .      VectorGeneric(VectorContainerGeneric),
          .  }
          .  
          .  impl FpVector {
          .      fn wrap_container(p : u32, vector_container : VectorContainer) -> FpVector {
          .          match p {
  2,190,824              2 => FpVector::Vector2(VectorContainer2 { vector_container }),
          .              3 => FpVector::Vector3(VectorContainer3 { vector_container }),
          .              5 => FpVector::Vector5(VectorContainer5 { vector_container }),
          .              _ => FpVector::VectorGeneric(VectorContainerGeneric { p, vector_container })
          .          }
          .      }
          .  
          .      fn get_vector_container_mut(&mut self) -> &mut VectorContainer {
          .          match self {
-- line 238 ----------------------------------------
-- line 249 ----------------------------------------
          .              FpVector::Vector3(v) => &v.vector_container,
          .              FpVector::Vector5(v) => &v.vector_container,
          .              FpVector::VectorGeneric(v) => &v.vector_container,
          .          }
          .      }
          .  
          .      pub fn get_prime(&self) -> u32 {
          .          match self {
654,764,262              FpVector::Vector2(_) => 2,
          .              FpVector::Vector3(_) => 3,
          .              FpVector::Vector5(_) => 5,
          .              FpVector::VectorGeneric(v) => v.p,
          .          }
          .      }
          .  
          .      pub fn get_dimension(&self) -> usize {
          .          let container = self.get_vector_container();
 29,661,360          return container.slice_end - container.slice_start;
          .      }
          .  
  2,961,031      pub fn get_offset(&self) -> usize {
          .          let container = self.get_vector_container();
          .          let bit_length = get_bit_length(self.get_prime());
          .          let entries_per_64_bits = get_entries_per_64_bits(self.get_prime());
 23,688,248          return (container.offset + container.slice_start * bit_length) % (bit_length * entries_per_64_bits);
  5,922,062      }
          .  
          .      pub fn get_min_index(&self) -> usize {
          .          let container = self.get_vector_container();
          .          let bit_length = get_bit_length(self.get_prime());
203,582,300          return container.offset/bit_length + container.slice_start;
          .      }
          .  
          .      pub fn set_slice(&mut self, slice_start : usize, slice_end : usize) {
          .          let container = self.get_vector_container_mut();
    566,485          container.slice_start = slice_start;
    754,738          container.slice_end = slice_end;
          .      }
          .  
          .      pub fn clear_slice(&mut self) {
          .          let container = self.get_vector_container_mut();
    503,050          container.slice_start = 0;
  1,038,202          container.slice_end = container.dimension;
          .      }
          .  
          .      fn get_min_limb(&self) -> usize {
          .          let p = self.get_prime();
          .          let bit_length = get_bit_length(p);
          .          let container = self.get_vector_container();
 46,155,700          get_limb_bit_index_pair(p,container.offset/bit_length + container.slice_start).limb
          .      }
          .  
          .      fn get_max_limb(&self) -> usize {
          .          let p = self.get_prime();
          .          let bit_length = get_bit_length(p);        
          .          let container = self.get_vector_container();
 43,114,529          if container.offset/bit_length + container.slice_end > 0{
 21,556,624              get_limb_bit_index_pair(p, container.offset/bit_length + container.slice_end - 1).limb + 1
          .          } else {
          .              0
          .          }
          .      }
          .  
          .      // Private
          .  
          .      fn get_limbs_cvec(&self) -> &CVec<u64> {
          .          &self.get_vector_container().limbs
          .      }
          .  
          .      fn get_limbs_cvec_mut(&mut self) -> &mut CVec<u64> {
          .          &mut self.get_vector_container_mut().limbs
          .      }
          .  
 20,277,789      fn get_limb_mask(&self, limb_idx : usize) -> u64 {
  5,793,654          let offset = self.get_offset();        
107,182,599  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_offset (2896827x)
          .          let min_limb = self.get_min_limb();
          .          let max_limb = self.get_max_limb();
  2,896,827          let number_of_limbs = max_limb - min_limb;
          .          let mut mask = !0;
 20,277,789          if limb_idx == 0 {
          .              mask <<= offset;
          .          }
  8,690,481          if limb_idx + 1 == number_of_limbs {
          .              let p = self.get_prime();
          .              let dimension = self.get_dimension();
          .              let bit_length = get_bit_length(p);
          .              let entries_per_64_bits = get_entries_per_64_bits(p);
  1,455,741              let bits_needed_for_entire_vector = offset + dimension * bit_length;
  1,455,741              let usable_bits_per_limb = bit_length * entries_per_64_bits;
 10,190,187              let bit_max = 1 + ((bits_needed_for_entire_vector - 1)%(usable_bits_per_limb));                
  4,367,223              mask &= (!0) >> (64 - bit_max);
          .          }
          .          return mask;
 20,277,789      }
          .  
          .      fn unpack_limb(p : u32, dimension : usize, offset : usize, limb_array : &mut [u32], limbs : &CVec<u64>, limb_idx : usize) -> usize {
          .          let bit_length = get_bit_length(p);
          .          let entries_per_64_bits = get_entries_per_64_bits(p);
          .          let bit_mask = get_bitmask(p);    
          .          let mut bit_min = 0usize;
          .          let mut bit_max = bit_length * entries_per_64_bits;    
          .          if limb_idx == 0 {
-- line 350 ----------------------------------------
-- line 397 ----------------------------------------
          .          for j in (bit_min .. bit_max).step_by(bit_length) {
          .              limb_value |= (limb_array[idx] as u64) << j;
          .              idx += 1;
          .          }
          .          limbs[limb_idx] = limb_value;
          .          return idx;
          .      }    
          .  
          6      pub fn set_to_zero(&mut self){ 
          .          let min_limb = self.get_min_limb();
          .          let max_limb = self.get_max_limb();
          .          let number_of_limbs = max_limb - min_limb;
          3          for i in 1..number_of_limbs-1 {
          .              let limbs = self.get_limbs_cvec_mut();
          .              limbs[min_limb + i] = 0;
          .          }
          .          let mut i = 0; {
          3              let mask = self.get_limb_mask(i);
        134  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (1x)
          .              let limbs = self.get_limbs_cvec_mut();
          2              limbs[min_limb + i] &= !mask;
          .          }
          .          i = number_of_limbs - 1;
          2          if i > 0 {
          3              let mask = self.get_limb_mask(i);
        160  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (1x)
          .              let limbs = self.get_limbs_cvec_mut();
          3              limbs[min_limb + i] &= !mask;
          .          }
          6      }
          .  
    288,918      pub fn assign(&mut self, other : &Self){
          .          let min_target_limb = self.get_min_limb();
          .          let max_target_limb = self.get_max_limb();
          .          let min_source_limb = other.get_min_limb();
     64,204          let number_of_limbs = max_target_limb - min_target_limb;
    128,408          assert_eq!(number_of_limbs, other.get_max_limb() - other.get_min_limb());
    224,714          assert!(self.get_offset() == other.get_offset());
  2,375,548  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_offset (64204x)
          .          let target_limbs = self.get_limbs_cvec_mut();
          .          let source_limbs = other.get_limbs_cvec();
          .          for i in 1 .. number_of_limbs.saturating_sub(1) {
    461,530              target_limbs[min_target_limb + i] = source_limbs[min_source_limb + i];
          .          }        
          .          let mut i=0; { 
     96,306              let mask = other.get_limb_mask(i);
  4,483,980  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (32102x)
          .              let result = source_limbs[min_source_limb + i] & mask;
     64,204              target_limbs[min_target_limb + i] &= !mask;
     32,102              target_limbs[min_target_limb + i] |= result;
          .          }
     32,102          i = number_of_limbs - 1;
     64,204          if i > 0 { 
     50,180              let mask = other.get_limb_mask(i);
  4,014,400  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (25090x)
     25,090              let result = source_limbs[min_source_limb + i] & mask;
     75,270              target_limbs[min_target_limb + i] &= !mask;
     25,090              target_limbs[min_target_limb + i] |= result;
          .          }
    256,816      }    
          .  
          .      pub fn zeroq(&self) -> bool{
          .          let min_limb = self.get_min_limb();
          .          let max_limb = self.get_max_limb();
          .          let number_of_limbs = max_limb - min_limb;
          .          let limbs = self.get_limbs_cvec();
          .          for i in 1 .. number_of_limbs-1 {
          .              if limbs[min_limb + i] != 0 {
-- line 459 ----------------------------------------
-- line 505 ----------------------------------------
          .              let other_limb_masked = other_limbs[other_min_limb + i] & mask;
          .              if self_limb_masked != other_limb_masked {
          .                  return false;
          .              }
          .          }
          .          return true;
          .      }
          .  
 40,176,716      pub fn get_entry(&self, index : usize) -> u32 {
          .          let p = self.get_prime();   
          .          let bit_mask = get_bitmask(p);
 40,176,716          let limb_index = get_limb_bit_index_pair(p, index + self.get_min_index());
120,530,148          let mut result = self.get_limbs_cvec()[limb_index.limb];
 80,353,432          result >>= limb_index.bit_index;
          .          result &= bit_mask;
 40,176,716          return result as u32;
 80,353,432      }
          .  
  1,079,488      pub fn set_entry(&mut self, index : usize, value : u32){
          .          let p = self.get_prime();   
          .          let bit_mask = get_bitmask(p);
    539,744          let limb_index = get_limb_bit_index_pair(p, index + self.get_min_index());
          .          let limbs = self.get_limbs_cvec_mut();
  1,079,488          let mut result = limbs[limb_index.limb];
  2,158,976          result &= !(bit_mask << limb_index.bit_index);
  1,619,232          result |= (value as u64) << limb_index.bit_index;
    539,744          limbs[limb_index.limb] = result;
  1,079,488      }
          .  
          .      pub fn add_basis_element(&mut self, index : usize, value : u32){
  1,430,463          let mut x = self.get_entry(index);
  1,701,918  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_entry (31517x)
    476,821          x += value;
    953,642          x = x % self.get_prime();
    992,758          self.set_entry(index, x);
  1,891,020  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::set_entry (31517x)
          .      }
          .  
          .      pub fn unpack(&self, target : &mut [u32]){
          .          assert!(self.get_dimension() <= target.len());
          .          let p = self.get_prime();
          .          let dimension = self.get_dimension();
          .          let offset = self.get_offset();
          .          let limbs = self.get_limbs_cvec();
-- line 546 ----------------------------------------
-- line 559 ----------------------------------------
          .          let mut source_idx = 0;
          .          for i in 0..limbs.len() {
          .              source_idx += Self::pack_limb(p, dimension, offset, &source[source_idx ..], limbs, i);
          .          }
          .      }    
          .  
          .      fn add_limb(p : u32, limb_a : u64, limb_b : u64, coeff : u32) -> u64{
          .          match p {
 16,284,678              2 => VectorContainer2::add_limb(limb_a, limb_b, coeff),
          .              3 => VectorContainer3::add_limb(limb_a, limb_b, coeff),
          .              5 => VectorContainer5::add_limb(limb_a, limb_b, coeff),
          .              _ => VectorContainerGeneric::add_limb(limb_a, limb_b, coeff)
          .          }
          .      }
          .  
 14,236,380      fn reduce_limbs(&mut self, start_limb : usize, end_limb : usize) {
          .          match self {
  9,965,466              FpVector::Vector2(v) => v.reduce_limbs(start_limb, end_limb),
          .              FpVector::Vector3(v) => v.reduce_limbs(start_limb, end_limb),
          .              FpVector::Vector5(v) => v.reduce_limbs(start_limb, end_limb),
          .              FpVector::VectorGeneric(v) => v.reduce_limbs(start_limb, end_limb),
          .          }
 11,389,104      }    
          .  
 13,607,160      pub fn add(&mut self, other : &Self, c : u32){
          .          debug_assert!(self.get_prime() == other.get_prime());
          .          debug_assert!(self.get_offset() == other.get_offset());          
          .          debug_assert!(self.get_dimension() == other.get_dimension());
          .          let p = self.get_prime();
          .          let min_target_limb = self.get_min_limb();
          .          let max_target_limb = self.get_max_limb();
          .          let min_source_limb = other.get_min_limb();
          .          let max_source_limb = other.get_max_limb();
          .          debug_assert!(max_source_limb - min_source_limb == max_target_limb - min_target_limb);
          .          let number_of_limbs = max_source_limb - min_source_limb;
          .          let target_limbs = self.get_limbs_cvec_mut();
          .          let source_limbs = other.get_limbs_cvec();
  4,082,148          for i in 1..number_of_limbs-1 {
110,939,748              target_limbs[i + min_target_limb] = Self::add_limb(p, target_limbs[i + min_target_limb], source_limbs[i + min_source_limb], c);
          .          }
          .          let mut i = 0; {
  2,721,432              let mask = other.get_limb_mask(i);
182,526,238  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (1360716x)
          .              let source_limb_masked = source_limbs[min_source_limb + i] & mask;
  2,721,432              target_limbs[i + min_target_limb] = Self::add_limb(p, target_limbs[i + min_target_limb], source_limb_masked, c);
          .          }
          .          i = number_of_limbs - 1;
  2,728,751          if i > 0 {
  2,706,794              let mask = other.get_limb_mask(i);
216,543,520  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (1353397x)
  1,353,397              let source_limb_masked = source_limbs[min_source_limb + i] & mask;
  4,060,191              target_limbs[i + min_target_limb] = Self::add_limb(p, target_limbs[i + min_target_limb], source_limb_masked, c);
          .          }
 14,967,876          self.reduce_limbs(min_target_limb, max_target_limb);
 34,017,900  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::reduce_limbs (1360716x)
          .      }
          .  
          .      pub fn scale(&mut self, c : u32){
          .          let c = c as u64;
          .          let number_of_limbs = self.get_limbs_cvec_mut().len();
          .          let min_limb = self.get_min_limb();
          .          let max_limb = self.get_max_limb();
     62,922          for i in 1..number_of_limbs-1 {
          .              let limbs = self.get_limbs_cvec_mut();
  3,711,000              limbs[i + min_limb] *= c;
          .          }
          .          let mut i = 0; {
    188,766              let mask = self.get_limb_mask(i);
  8,439,972  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (62922x)
          .              let limbs = self.get_limbs_cvec_mut();
     62,922              let full_limb = limbs[min_limb + i];
    125,844              let masked_limb = full_limb & mask;
    125,844              let rest_limb = full_limb & !mask;
    251,688              limbs[i + min_limb] = (masked_limb * c) | rest_limb;
          .          }
          .          i = number_of_limbs - 1;
    188,766          if i > 0 {
    187,794              let mask = self.get_limb_mask(i);
 10,015,680  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_limb_mask (62598x)
          .              let limbs = self.get_limbs_cvec_mut();
    125,196              let full_limb = limbs[min_limb + i];
    125,196              let masked_limb = full_limb & mask;
    125,196              let rest_limb = full_limb & !mask;
    250,392              limbs[i + min_limb] = (masked_limb * c) | rest_limb;
          .          }
    188,766          self.reduce_limbs(min_limb, max_limb);
  1,573,050  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::reduce_limbs (62922x)
          .      }
          .  }
          .  
          .  impl FpVector {
          .      pub fn get_number_of_limbs(p : u32, dimension : usize, offset : usize) -> usize {
    257,744          assert!(dimension < MAX_DIMENSION);
          .          assert!(offset < 64);
          .          let bit_length = get_bit_length(p);
    515,488          if dimension == 0 {
          .              return 0;
          .          } else {
    514,460              return get_limb_bit_index_pair(p, dimension + offset/bit_length - 1).limb + 1;
          .          }
          .      }
          .  
  1,030,976      pub fn new(p : u32, dimension : usize, offset : usize) -> FpVector {
          .          assert!(offset < 64);
    257,744          assert_eq!(offset % get_bit_length(p), 0);
          .          let slice_start = 0;
          .          let slice_end = dimension;
          .          let number_of_limbs = Self::get_number_of_limbs(p, dimension, offset);
          .          let mut limbs_inner : Vec<u64> = Vec::with_capacity(number_of_limbs);
          .          for _ in 0..number_of_limbs {
          .              limbs_inner.push(0);
          .          }
        771          let limbs = memory::CVec::from_vec(limbs_inner);
          .          let vector_container = VectorContainer {dimension, offset, limbs, slice_start, slice_end };
          .          FpVector::wrap_container(p, vector_container)
  1,030,976      }
          .  
          .      pub fn new_from_allocator<T : MemoryAllocator>(allocator : &T, p : u32, dimension : usize, offset : usize) -> FpVector {
          .          assert!(offset < 64);
          .          let number_of_limbs = Self::get_number_of_limbs(p, dimension, offset);
          .          let limbs = allocator.alloc_vec(number_of_limbs);
          .          let slice_start = 0;
          .          let slice_end = dimension;
          .          let vector_container = VectorContainer {dimension, offset, limbs, slice_start, slice_end };        
          .          FpVector::wrap_container(p, vector_container)
          .      }
          .  
          .      pub fn get_padded_dimension(p : u32, dimension : usize, offset : usize) -> usize {
          .          let entries_per_limb = get_entries_per_64_bits(p);
          .          let bit_length = get_bit_length(p);
     42,500          return ((dimension + offset/bit_length + entries_per_limb - 1)/entries_per_limb)*entries_per_limb;
          .      }
          .  }
          .  
          .  impl FpVector {
          .      pub fn iter(&self) -> FpVectorIterator{
  1,070,836          FpVectorIterator {
          .              vect : &self,
          .              index : 0
          .          }
          .      }
          .  }
          .  pub struct FpVectorIterator<'a> {
          .      vect : &'a FpVector,
          .      index : usize
          .  }
          .  
          .  
          .  impl<'a> Iterator for FpVectorIterator<'a> {
          .      type Item = u32;
          .      fn next(&mut self) -> Option<Self::Item>{
 31,297,462          if self.index < self.vect.get_dimension() {
 31,658,438              let result = Some(self.vect.get_entry(self.index));
166,872,096  => src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_entry (3090224x)
 14,701,992              self.index += 1;
          .              result
          .          } else {
          .              None
          .          }
          .      }
          .  }
          .  
          .  impl fmt::Display for FpVector {
-- line 714 ----------------------------------------

387,079,574  <counts for unidentified lines in src/fp_vector.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/adem_algebra.rs
--------------------------------------------------------------------------------
        Ir 

-- line 26 ----------------------------------------
         .              table[bits_set].push(i);
         .          }
         .          table
         .      };
         .  }
         .  
         .  // #[derive(RustcDecodable, RustcEncodable)]
         .  #[derive(Debug)]
     6,171  #[derive(Clone)]
         .  pub struct AdemBasisElement {
         .      pub degree : i32,
         .      pub excess : i32,
         .      pub bocksteins : u32,
    10,285      pub ps : Vec<u32>
 1,097,905  => /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs:<alloc::vec::Vec<T> as core::clone::Clone>::clone (4114x)
         .  }
         .  
         .  impl std::cmp::PartialEq for AdemBasisElement {
         .      fn eq(&self, other : &Self) -> bool {
 2,028,591          self.ps == other.ps && self.bocksteins == other.bocksteins
         .      }
         .  }
         .  
         .  impl std::cmp::Eq for AdemBasisElement {}
         .  
         .  impl std::hash::Hash for AdemBasisElement {
         .      fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
         .          self.bocksteins.hash(state);
-- line 52 ----------------------------------------
-- line 101 ----------------------------------------
         .      }
         .  }
         .  
         .  unsafe fn shift_vec<T>(v : Vec<T> , offset : isize) -> Vec<T> {
         .      let ptr = v.as_ptr();
         .      let len = v.len();
         .      let cap = v.capacity();
         .      std::mem::forget(v);        
 2,719,636      Vec::from_raw_parts((ptr as *mut T).offset(offset), (len as isize - offset) as usize, (cap as isize - offset) as usize)
         .  }
         .  
         .  pub struct AdemAlgebra {
         .      p : u32,
         .      name : String,
         .      pub generic : bool,
         .      // FiltrationOneProduct_list product_list; // This determines which indecomposibles have lines drawn for them.
         .      unstable : bool,
-- line 117 ----------------------------------------
-- line 121 ----------------------------------------
         .      multiplication_table : Vec<Once<Vec<Vec<FpVector>>>>,// degree -> first square -> admissibile sequence idx -> result vector
         .      excess_table : Vec<Once<Vec<u32>>>,
         .      sort_order : Option<fn(&AdemBasisElement, &AdemBasisElement) -> Ordering>,
         .      filtration_one_products : Vec<(String, AdemBasisElement)> //Vec<Once<(i32, usize)>>
         .  }
         .  
         .  impl Algebra for AdemAlgebra {
         .      fn get_prime(&self) -> u32 {
   133,345          self.p
   133,345      }
         .  
         .      fn get_max_degree(&self) -> i32 {
         .          for i in 0..self.basis_table.len() {
         .              if !self.basis_table[i].has() {
         .                  return i as i32;
         .              }
         .          }
         .          return self.basis_table.len() as i32;
         .      }
         .  
         .      fn get_name(&self) -> &str {
         .          &self.name
         2      }
         .  
         .      fn get_filtration_one_products(&self) -> Vec<(&str, i32, usize)>{
         .          self.filtration_one_products.iter()
         .              .filter(|(_ , b)| self.multiplication_table[b.degree as usize].has())
         .              .map(|(name, b)| (&**name, b.degree, self.basis_element_to_index(b)))
         .              .collect::<Vec<_>>()
         .          // self.filtration_one_products.iter()
         .          //     .filter_map(|val| val.get_option())
         .          //     .map(|val| val.clone())
         .          //     .collect::<Vec<_>>()
         .      }
         .  
         7      fn compute_basis(&self, mut max_degree : i32) {
         2          let genericq = if self.generic { 1 } else { 0 };
         3          assert!(max_degree + genericq <= self.basis_table.len() as i32);
         5          combinatorics::initialize_prime(self.p);
       377  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/combinatorics.rs:rust_ext::combinatorics::initialize_prime (1x)
         .          let mut old_max_degree = self.get_max_degree();
         2          if max_degree <= old_max_degree {
         .              return;
         .          }        
         3          if self.generic {
         .              // generateMultiplcationTableGeneric sometimes goes over by one due to its bockstein logic.
         .              // rather than testing for this, we take the lazy way out and calculate everything else out one extra step.
         .              max_degree += 1;
         .              if old_max_degree > 0 {
         .                  old_max_degree += 1; // If we've done work before, we also did that one extra step.
         .              }
         .          }
         .          let mut max_degree = max_degree;
         .          let mut old_max_degree = old_max_degree;
         .          if self.generic {
         .              self.generate_basis_generic(old_max_degree, max_degree);
         .          } else {
         .              self.generate_basis2(old_max_degree, max_degree);
         .          }
         .          self.generate_basis_element_to_index_map(old_max_degree, max_degree);
         2          if self.generic {
         .              // AdemAlgebra__generateMultiplicationTable consumes the one extra degree we computed in the generic case
         .              max_degree -= 1;
         .              if old_max_degree > 0 {
         .                  old_max_degree -= 1;
         .              }
         .          }
         2          self.generate_multiplication_table(old_max_degree, max_degree);
73,850,720  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::generate_multiplication_table (1x)
         .          // if self.max_degree 
         .          // println!("self.generate_multiplication_table({}, {})", old_max_degree, max_degree);
         .          // if self.unstable {
         .          //     self.generate_excess_table(old_max_degree, max_degree);
         .          // }
         .          // Make sure product_list reflects sort order.
         .          // for i in 0 .. self.filtrationOneProduct_basisElements.length {
         .          //     AdemBasisElement *b = self.filtrationOneProduct_basisElements.list[i];
         .          //     if(b->degree < max_degree){
         .          //         self->product_list.list[i].index = self.basis_element_to_index(b);
         .          //     }
         .          // }
         8      }
         .  
   606,634      fn get_dimension(&self, degree : i32, excess : i32) -> usize {
 2,329,378          if degree < 0 {
         .              return 0;
         .          }
 1,153,637          return self.basis_table[degree as usize].get().len();
 1,213,268      }
         .  
 1,901,648      fn multiply_basis_elements(&self, result : &mut FpVector, coeff : u32, 
         .          r_degree : i32, r_index : usize, 
         .          s_degree : i32, s_index : usize, excess : i32)
         .      {
         .          self.multiply(result, coeff, r_degree, r_index, s_degree, s_index, excess);
 2,173,312      }
         .  
         .      fn basis_element_to_string(&self, degree : i32, idx : usize) -> String {
         .          format!("{}", self.basis_element_from_index(degree, idx))
         .      }
         .  }
         .  
         .  // static void AdemAlgebra__initializeFields(AdemAlgebraInternal *algebra, uint p, bool generic, bool unstable);
         .  // uint AdemAlgebra__generateName(AdemAlgebra *algebra); // defined in adem_io
         .  impl AdemAlgebra {
         .      pub fn new(p : u32, generic : bool, unstable : bool, max_degree : i32) -> Self {
         2          crate::combinatorics::initialize_prime(p);
     1,071  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/combinatorics.rs:rust_ext::combinatorics::initialize_prime (1x)
         .          crate::fp_vector::initialize_limb_bit_index_table(p);
         2          assert!(max_degree >= 0);
         .          let mut max_degree = max_degree as usize;
         1          if generic {
         .              max_degree += 1;
         .          }
         .          let mut even_basis_table = Vec::with_capacity(max_degree);
         .          let mut basis_table = Vec::with_capacity(max_degree);
         .          let mut basis_element_to_index_map = Vec::with_capacity(max_degree);
         .          let mut multiplication_table = Vec::with_capacity(max_degree);
         .          let mut excess_table = Vec::with_capacity(max_degree);
         .          for i in 0..max_degree {
         .              even_basis_table.push(Once::new());
         .              basis_table.push(Once::new());
         .              basis_element_to_index_map.push(Once::new());
         .              multiplication_table.push(Once::new());
         .              excess_table.push(Once::new());
         .          }
         .          let mut filtration_one_products = Vec::with_capacity(4);
         1          if generic {
         .              filtration_one_products.push(("a_0".to_string(), AdemBasisElement {
         .                  degree : 1,
         .                  bocksteins : 1,
         .                  excess : 0,
         .                  ps : vec![]
         .              }));
         .              filtration_one_products.push(("h_0".to_string(), AdemBasisElement {
         .                  degree : (2*p-2) as i32,
         .                  bocksteins : 0,
         .                  excess : 0,
         .                  ps : vec![1]
         .              }));
         .          } else {
         4              for i in 0..4 {
         .                  let degree = 1 << i; // degree is 2^hi 
         4                  let ps = vec![degree as u32];
        56                  filtration_one_products.push((format!("h_{}", i),AdemBasisElement {
     2,330  => /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c//src/liballoc/fmt.rs:alloc::fmt::format (4x)
         .                      degree,
         .                      bocksteins : 0,
         .                      excess : 0,
         .                      ps
         .                  }));
         .              }
         .          }
        35          Self {
         1              p,
         4              name : format!("AdemAlgebra(p={})", p),
       605  => /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c//src/liballoc/fmt.rs:alloc::fmt::format (1x)
         .              generic,
         .              unstable,
         .              even_basis_table,
         .              basis_table,
         .              basis_element_to_index_map,
         .              multiplication_table,
         .              excess_table,
         .              sort_order : None,
         .              filtration_one_products
         .          }
         .      }
         .  
         9      fn generate_basis_even(&self, mut old_max_degree : i32, max_degree : i32){
         2          if old_max_degree == 0 {
         .              let mut table = Vec::with_capacity(1);
         .              table.push(
         4                  AdemBasisElement {
         .                      degree : 0,
         .                      excess : 0,
         .                      bocksteins : 0,
         .                      ps : vec![]
         .                  }
         .              );
         6              self.even_basis_table[0].set(table);
        38  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/once.rs:rust_ext::once::Once<T>::set (1x)
         .              old_max_degree += 1;
         .          }
         .  
         .          for n in old_max_degree .. max_degree {
         .              self.generate_basis_even_degreen(n);
         .          }
         8      }
         .  
         .      fn generate_basis_even_degreen(&self, n : i32){
        49          let p = self.p as i32;
         .          let mut basis = Vec::new();
         .          // Put Sqn into the list.
         .          basis.push(
       294              AdemBasisElement {
         .                  degree : n,
         .                  excess : n,
       294                  bocksteins : if self.generic { u32::max_value() << 2 } else { 0 },
        49                  ps : vec![n as u32]
         .              }
         .          );
         .  
         .          // last = last term. We append (last,) to the end of
         .          // elements of degree n - last whose own last square is
         .          // at least p * last.
         .          // In order for this to be possible, this means that p last <= n - last, 
         .          // or (p+1) * last <= n or last <= n/(p+1). We order the squares in decreasing
         .          // order of their last element so that as we walk over the previous basis
         .          // when we find a square whose end is too small, we can break.
       392          for last in (1 .. n/(p+1) + 1).rev() {
     1,176              let previous_basis = self.even_basis_table[(n-last) as usize].get();
         .              for prev_elt in previous_basis {
         .                  let prev_elt_p_len = prev_elt.ps.len();
     2,398                  let old_last_sq = prev_elt.ps[prev_elt_p_len - 1] as i32;
     4,796                  if old_last_sq < p * last {
         .                      break;
         .                  }
         .                  // Write new basis element to basis element buffer
         .                  
     2,007                  let degree = prev_elt.degree + last;
     4,014                  let excess = prev_elt.excess - (p-1)*last;
         .                  // We're using bocksteins as a bit mask:
         .                  // A bit in bocksteins shall be set if it's illegal for a bockstein to occur there.
     2,007                  let mut bocksteins = prev_elt.bocksteins; 
     6,021                  if self.generic{
         .                      bocksteins |= if old_last_sq == p*last { 1 << prev_elt_p_len } else { 0 };
         .                      bocksteins &= !(1 << (prev_elt_p_len +1));
         .                  }
     2,007                  let mut ps : Vec<u32> = Vec::with_capacity(prev_elt_p_len + 1);
         .                  for k in &prev_elt.ps {
     4,477                      ps.push(*k);
         .                  }
         .                  ps.push(last as u32);
     8,028                  basis.push(AdemBasisElement {
         .                      degree,
         .                      excess,
         .                      bocksteins,
    10,035                      ps
         .                  });
         .              }
         .          }
       294          self.even_basis_table[n as usize].set(basis);
     1,862  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/once.rs:rust_ext::once::Once<T>::set (49x)
         .      }
         .  
         .  
         .      fn generate_basis2(&self, old_max_degree : i32, max_degree : i32){
         4          self.generate_basis_even(old_max_degree, max_degree);
   802,459  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::generate_basis_even (1x)
         2          for n in old_max_degree as usize .. max_degree as usize {
         .              let table = self.even_basis_table[n].get();
       100              self.basis_table[n].set(table.clone());
     1,900  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/once.rs:rust_ext::once::Once<T>::set (50x)
         .          }
         .          // if let Some(f) = self.sort_order {
         .          //     for 
         .          // }
         .  
         .      }
         .  
         .  
-- line 373 ----------------------------------------
-- line 433 ----------------------------------------
         .          }
         .          self.basis_table[n as usize].set(basis);
         .          // if let Some(f) = self.sort_order {
         .              // qsort(basisElementBuffer, cur_basis_len, sizeof(AdemBasisElement), algebra->public_algebra.sort_order);
         .          // }
         .      }
         .  
         .      fn generate_basis_element_to_index_map(&self, old_max_degree : i32, max_degree : i32){
         1          for n in old_max_degree as usize .. max_degree as usize {
         .              let basis = self.basis_table[n].get();
         .              let mut map = HashMap::with_capacity(basis.len());
         .              for i in 0 .. basis.len() {
         .                  map.insert(basis[i].clone(), i);
         .              }
         .              self.basis_element_to_index_map[n as usize].set(map);
         .          }
         .      }
         .  
         .      pub fn basis_element_from_index(&self, degree : i32, idx : usize) -> &AdemBasisElement {
         .          &self.basis_table[degree as usize].get()[idx]
         .      }
         .  
 2,024,478      pub fn basis_element_to_index(&self, elt : &AdemBasisElement) -> usize {
 4,048,956          if let Some(idx) = self.basis_element_to_index_map[elt.degree as usize].get().get(elt) {
390,367,957  => /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libstd/collections/hash/map.rs:std::collections::hash::map::HashMap<K,V,S>::get (1012239x)
 1,012,239              *idx
         .          } else {
         .              println!("Didn't find element: {:?}", elt);
         .              assert!(false);
         .              0
         .          }
 2,024,478      }
         .  
 4,818,762      fn tail_of_basis_element_to_index(&self, mut elt : AdemBasisElement, idx : u32, q : u32) -> (AdemBasisElement, usize) {
   535,418          let degree = elt.degree;
   535,418          let bocksteins = elt.bocksteins;
   535,418          for i in 0..idx as usize {
 7,192,619              elt.degree -= (q * elt.ps[i] + (elt.bocksteins & 1)) as i32;
 2,055,034              elt.bocksteins >>= 1;            
         .          }
 1,606,254          unsafe { elt.ps = shift_vec(elt.ps, idx as isize); }
 1,606,254          let result  = self.basis_element_to_index(&elt);
213,756,207  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index (535418x)
 1,606,254          unsafe { elt.ps = shift_vec(elt.ps, -(idx as isize)); }
   535,418          elt.degree = degree;
   535,418          elt.bocksteins = bocksteins;
 5,889,598          return (elt, result);
 3,747,926      }
         .  
         8      fn generate_multiplication_table(&self, old_max_degree : i32, max_degree : i32){
         3          if self.generic {
         .              self.generate_multiplication_table_generic(old_max_degree, max_degree);
         .          } else {
         .              self.generate_multiplication_table_2(old_max_degree, max_degree);
         .          }
         8      }    
         .  
         .      fn generate_multiplication_table_2(&self, mut old_max_degree : i32, max_degree : i32){
         .          // degree -> first_square -> admissibile sequence idx -> result vector
         2          if old_max_degree == 0 {
         1              self.multiplication_table[0].set(Vec::new());
        54  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/once.rs:rust_ext::once::Once<T>::set (1x)
         .              old_max_degree += 1;
         .          }
         .          for n in old_max_degree .. max_degree {
         .              let mut table : Vec<Vec<FpVector>> = Vec::with_capacity((n + 1) as usize);
         .              table.push(Vec::with_capacity(0));
         .              for x in 1 .. n + 1 {
         .                  let dimension = self.get_dimension(n - x, -1);
         .                  table.push(Vec::with_capacity(dimension));
-- line 499 ----------------------------------------
-- line 502 ----------------------------------------
         .                  for idx in 0 .. self.get_dimension(n - x, -1) {
         .                      let entry;
         .                      unsafe {
         .                          entry = &mut *(&mut table[x as usize] as *mut Vec<FpVector>);
         .                      }
         .                      entry.push(self.generate_multiplication_table2_step(&table, n, x, idx));
         .                  }
         .                  let dimension = self.get_dimension(n - x, -1);
     3,675                  assert!(table[x as usize].len() == dimension);
         .              }
       392              self.multiplication_table[n as usize].set(table);
     2,646  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/once.rs:rust_ext::once::Once<T>::set (49x)
         .          }
         .      }
         .  
         .      fn generate_multiplication_table2_step(&self, table : &Vec<Vec<FpVector>>, n : i32, x : i32, idx : usize) -> FpVector {
         .          let output_dimension = self.get_dimension(n, -1);
    69,987          let mut result = FpVector::new(self.p, output_dimension, 0);
 3,371,289  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::new (23329x)
         .          let cur_basis_elt = self.basis_element_from_index(n-x, idx);
   116,645          let mut working_elt = AdemBasisElement {
         .              degree : n,
         .              excess : 0,
         .              bocksteins : 0,
    23,329              ps : Vec::with_capacity(cur_basis_elt.ps.len() + 1)
         .          };
         .          working_elt.ps.push(x as u32);
         .          for cur_p in &cur_basis_elt.ps {
    67,934              working_elt.ps.push(*cur_p);
         .          }
         .          // println!("working_elt: {:?}", working_elt);
    46,658          assert!(working_elt.ps.len() == working_elt.ps.capacity());
         .          // Be careful to deal with the case that cur_basis_elt has length 0            
         .          // If the length is 0 or the sequence is already admissible, we can just write a 1 in the answer
         .          // and continue.
   186,436          if cur_basis_elt.ps.len() == 0 || x as u32 >= 2*cur_basis_elt.ps[0] {
     4,112              let out_idx = self.basis_element_to_index(&working_elt);
   852,681  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index (2056x)
         .              result.add_basis_element(out_idx, 1);
         .              return result;
         .          }
    21,273          let y = working_elt.ps[1] as i32;
         .          // We only needed the extra first entry to perform the lookup if our element
         .          // happened to be admissible. Otherwise, take the rest of the list and forget about it.
    42,546          working_elt.degree -= working_elt.ps[0] as i32;
    85,092          unsafe { working_elt.ps = shift_vec(working_elt.ps, 1) };
         .          for j in 0 .. 1 + x/2 {
   745,020              if combinatorics::binomial(2, y - j - 1, x - 2*j) == 0 {
         .                  continue;
         .              }
    80,636              if j==0 {
     6,220                  working_elt.ps[0] = (x + y) as u32;
    12,440                  working_elt.degree += x;
         .                  // In this case the result is guaranteed to be admissible so we can immediately add it to result
    12,440                  let out_idx = self.basis_element_to_index(&working_elt);
 2,566,401  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index (6220x)
         .                  result.add_basis_element(out_idx, 1);
         .                  continue;
         .              }
         .              // Now we need to reduce Sqj * (rest of Sqs)
         .              // The answer to this is in the table we're currently making.
   443,274              let tuple = self.tail_of_basis_element_to_index(working_elt, 1, 1);
15,799,699  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index (34098x)
   238,686              working_elt = tuple.0;
         .              let working_elt_idx = tuple.1;
         .              // total degree -> first sq -> idx of rest of squares
   102,294              let rest_reduced = &self.multiplication_table[(n as i32 - (x + y) + j) as usize].get()[j as usize][working_elt_idx];
         .              for (i, coeff) in rest_reduced.iter().enumerate() {
   536,856                  if coeff == 0 {
         .                      continue;
         .                  }
         .                  // Reduce Sq^{x+y-j} * whatever square using the table in the same degree, larger index
         .                  // Since we're doing the first squares in decreasing order and x + y - j > x, 
         .                  // we already calculated this.
         .                  let source = &table[x as usize + y as usize -j as usize][i as usize];
   132,868                  result.add(source, 1);
16,407,257  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::add (33217x)
         .              }
         .          }
   106,365          unsafe { working_elt.ps = shift_vec(working_elt.ps, -1) };
   340,368          return result;
         .      }
         .  
         .      fn generate_multiplication_table_generic(&self, mut old_max_degree : i32, max_degree : i32){
         .          // degree -> first_square -> admissibile sequence idx -> result vector
         .          let p = self.p as i32;
         .          let q = 2*p-2;
         .          if old_max_degree == 0 {
         .              self.multiplication_table[0].set(Vec::new());
-- line 584 ----------------------------------------
-- line 760 ----------------------------------------
         .          return (result, beta_result)
         .      }
         .  
         .  
         .      pub fn multiply(&self, result : &mut FpVector, coeff : u32, 
         .                              r_degree : i32, r_index : usize, 
         .                              s_degree : i32, s_index : usize, excess : i32)
         .      {
   543,328          if coeff == 0 {
         .              return;
         .          }
   543,328          assert!(r_index < self.get_dimension(r_degree, excess + s_degree));
   814,992          assert!(s_index < self.get_dimension(s_degree, excess));
         .  
   543,328          if s_degree == 0 {
         .              // If s is of length 0 then max_idx "r->P_length" is off the edge of the list and it segfaults.
         .              // Avoid this by returning early in this case.
         .              result.add_basis_element(r_index, coeff);
         .              return;
         .          }
         .          let r = self.basis_element_from_index(r_degree, r_index);
         .          let s = self.basis_element_from_index(s_degree, s_index);
 1,629,984          let mut monomial = AdemBasisElement {
         .              degree : r.degree + s.degree,
         .              excess : 0,
         .              bocksteins : 0,
   271,664              ps : Vec::with_capacity(r.ps.len() + s.ps.len())
         .          };
 1,358,320          if self.generic && (r.bocksteins >> r.ps.len()) & s.bocksteins & 1 == 1 {
         .              // If there is a bockstein at the end of r and one at the beginning of s, these run into each other
         .              // and the output is 0.
         .              return;
         .          } else if self.generic {
         .              monomial.bocksteins = r.bocksteins;
         .              monomial.bocksteins |= s.bocksteins << (r.ps.len());
         .          }
         .          
         .          for cur_p in &r.ps {
   673,189              monomial.ps.push(*cur_p);
         .          }
         .          for cur_p in &s.ps {
   507,278              monomial.ps.push(*cur_p);
         .          }        
 1,629,984          assert!(monomial.ps.len() == r.ps.len() + s.ps.len());
   271,664          if self.generic {
         .              // If r ends in a bockstein, we need to move it over because we consider
         .              // the monomial from right to left in chunks like bP^i. The b from the end of r gets donated
         .              // to the P from the beginning of s.
         .              let leading_degree = r.degree - ((r.bocksteins >> r.ps.len()) & 1) as i32;
         .              self.make_mono_admissible_generic(result, coeff, monomial, r.ps.len() as i32 - 1, leading_degree, excess, true);
         .          } else {
 2,716,640              self.make_mono_admissible_2(result, monomial, r.ps.len() as i32 - 1, r.degree, excess, true);
1,650,399,611  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2 (271664x)
         .          }
         .      }
         .  
         .      pub fn make_mono_admissible(&self, result : &mut FpVector, coeff : u32, monomial : AdemBasisElement, excess : i32){
         .          let q = if self.generic { 2 * self.p - 2 } else { 1 };
         .          let mut leading_degree = monomial.degree - (q * monomial.ps[monomial.ps.len() - 1]) as i32;
         .          let idx = monomial.ps.len() as i32 - 2;    
         .          if self.generic {
-- line 819 ----------------------------------------
-- line 830 ----------------------------------------
         .      *    algebra -- an Adem algebra. This would be a method of class AdemAlgebra.
         .      *    result  -- Where we put the result
         .      *    monomial -- a not necessarily admissible Steenrod monomial which we will reduce. 
         .      *                We destroy monomial->Ps.
         .      *    idx -- the only index to check for inadmissibility in the input (we assume that we've gotten
         .      *           our input as a product of two admissible sequences.)
         .      *    leading_degree -- the degree of the squares between 0 and idx (so of length idx + 1)
         .      */
10,668,515      fn make_mono_admissible_2(
         .          &self, result : &mut FpVector, mut monomial : AdemBasisElement,
         .          mut idx : i32, mut leading_degree : i32, excess : i32, stop_early : bool
         .      ){
 8,046,507          while idx < 0 || idx as usize == monomial.ps.len() - 1 || monomial.ps[idx as usize] >= 2*monomial.ps[idx as usize + 1] {
         .              if idx < 0 || stop_early {
         .                  // Admissible so write monomial to result.
 1,405,635                  let idx = self.basis_element_to_index(&monomial);
13,117,244  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::basis_element_to_index (31517x)
         .                  // If excess is too large, quit. It's faster to check this by comparing idx to dimension
         .                  // than to use fromIndex because fromIndex  dereferences a hash map.
   937,090                  if self.unstable && idx >= self.get_dimension(monomial.degree, excess) {
         .                      return;
         .                  }
         .                  result.add_basis_element(idx, 1);
         .                  return;
         .              }
         .              leading_degree -= monomial.ps[idx as usize] as i32;
         .              idx -= 1;
         .          }
 6,015,840          let tuple = self.tail_of_basis_element_to_index(monomial, idx as u32 + 1, 1);
117,874,985  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::tail_of_basis_element_to_index (240147x)
 3,007,920          monomial = tuple.0;
         .          let adm_idx = tuple.1;
   501,320          let x = monomial.ps[idx as usize] as i32;
 1,503,960          let tail_degree = monomial.degree - leading_degree + x;
   501,320          let reduced_tail = &self.multiplication_table[tail_degree as usize].get()[x as usize][adm_idx];
         .          for (it_idx, it_value) in reduced_tail.iter().enumerate() {
26,883,176              if it_value == 0 {
         .                  continue;
         .              }
         .              let cur_tail_basis_elt = self.basis_element_from_index(tail_degree, it_idx);
 6,982,010              let mut new_monomial = AdemBasisElement {
         .                  degree : monomial.degree,
         .                  excess : -1,
         .                  bocksteins : 0,
   698,201                  ps : Vec::with_capacity(idx as usize + cur_tail_basis_elt.ps.len())
         .              };
         .              for i in 0..idx {
   426,805                  new_monomial.ps.push(monomial.ps[i as usize]);
         .              }
         .              for cur_p in &cur_tail_basis_elt.ps {
 1,906,574                  new_monomial.ps.push(*cur_p);
         .              }
11,171,216              self.make_mono_admissible_2(result, new_monomial, idx - 1, leading_degree - x, excess, stop_early);
1,226,518,724  => src/adem_algebra.rs:rust_ext::adem_algebra::AdemAlgebra::make_mono_admissible_2'2 (202760x)
         .          }
 4,010,560      }
         .  
         .      fn make_mono_admissible_generic(
         .          &self, result : &mut FpVector, coeff : u32, mut monomial : AdemBasisElement,
         .          mut idx : i32, mut leading_degree : i32, excess : i32, stop_early : bool        
         .      ){
         .          let p = self.p;
         .          let q = 2*p-2;
         .          // Check for admissibility
-- line 890 ----------------------------------------

 9,495,173  <counts for unidentified lines in src/adem_algebra.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/memory.rs
--------------------------------------------------------------------------------
         Ir 

-- line 18 ----------------------------------------
          .      // We need the backing field so that if we wrap a Vec<> we keep it from being Dropped until we go out of scope.    
          .      backing : Option<Vec<T>> 
          .  }
          .  
          .  impl<T> std::ops::Deref for CVec<T> {
          .      type Target = [T];
          .  
          .      fn deref(&self) -> &[T] {
208,724,678          unsafe { slice::from_raw_parts(self.ptr, self.len) }
          .      }
          .  }
          .  
          .  impl<T> std::ops::DerefMut for CVec<T> {
          .      fn deref_mut(&mut self) -> &mut [T] {
  7,146,031          unsafe { slice::from_raw_parts_mut(self.ptr, self.len) }
     62,922      }
          .  }
          .  
          .  impl<T> std::ops::Index<usize> for CVec<T> {
          .      type Output = T;
          .      fn index(&self, i : usize) -> &Self::Output {
330,725,191          &self.deref()[i]
          .      }
          .  }
          .  
          .  impl<T> std::ops::IndexMut<usize> for CVec<T> {
          .      fn index_mut(&mut self, i : usize) -> &mut Self::Output {
 13,653,195          &mut self.deref_mut()[i]
          .      }
          .  }
          .  
          .  impl<T> Drop for CVec<T> {
          .      fn drop(&mut self) {
          .          
          .      }
          .  }
-- line 53 ----------------------------------------
-- line 63 ----------------------------------------
          .  }
          .  
          .  impl<T> CVec<T> {
          .      pub fn new(size : usize) -> Self {
          .          Self::from_vec(Vec::with_capacity(size))
          .      }
          .  
          .      pub fn from_vec(mut vec : Vec<T>) -> Self {
     15,000          Self {
          .              ptr: vec.as_mut_ptr(),
          .              len: vec.capacity(),
          .              backing : Some(vec)
          .          }
          .      }
          .  
          .      pub fn from_parts(ptr : *mut T, len : usize, backing : Option<Vec<T>>) -> Self {
          .          Self { 
-- line 79 ----------------------------------------

  9,019,868  <counts for unidentified lines in src/memory.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/free_module_homomorphism.rs
--------------------------------------------------------------------------------
       Ir 

-- line 12 ----------------------------------------
        .      outputs : Vec<Once<Vec<FpVector>>>, // degree --> input_idx --> output
        .      kernel : Vec<Once<Subspace>>,
        .      min_degree : i32,
        .      degree_shift : i32
        .  }
        .  
        .  impl ModuleHomomorphism for FreeModuleHomomorphism<'_, '_> {
        .      fn get_source(&self) -> &Module {
    4,950          self.source
        .      }
        .      fn get_target(&self) -> &Module {
        .          self.target
        .      }
        .  
        .      fn apply_to_basis_element(&self, result : &mut FpVector, coeff : u32, input_degree : i32, input_index : usize){
        .          assert!(input_degree >= self.source.min_degree);
        .          let input_degree_idx = (input_degree - self.source.min_degree) as usize;
        .          let table = &self.source.table[input_degree_idx].get();
        .          self.apply_to_basis_element_with_table(result, coeff, input_degree, table, input_index);
        .      }
        .  
        .      fn set_kernel(&self, degree : i32, kernel : Subspace){
        .          // println!("Setting kernel degree : {}, name : {}", degree, self.source.get_name());
        .          // println!("kernel : {}", kernel.matrix);
   10,000          let degree_idx = degree as usize - self.get_min_degree() as usize;
        .          self.kernel[degree_idx].set(kernel);
        .      }
        .      
        .      fn get_kernel(&self, degree : i32) -> Option<&Subspace> {
    4,900          let degree_idx = degree as usize - self.get_min_degree() as usize;
        .          return Some(self.kernel[degree_idx].get());
        .      }
        .  
        .      fn set_image(&self, degree : i32, image : Subspace){
        .  
        .      }
        .  
        .      fn get_image(&self, degree : i32) -> Option<&Subspace> {
-- line 49 ----------------------------------------
-- line 60 ----------------------------------------
        .  }
        .  // // Run FreeModule_ConstructBlockOffsetTable(source, degree) before using this on an input in that degree
        .  // void FreeModuleHomomorphism_applyToBasisElement(FreeModuleHomomorphism *f, Vector *result, uint coeff, int input_degree, uint input_index){
        .  
        .  // }
        .  
        .  
        .  impl<'a, 'b> FreeModuleHomomorphism<'a, 'b> {
      900      pub fn new(source : &'b FreeModule<'a>, target : &'b Module, min_degree : i32, degree_shift : i32, max_degree : i32) -> Self {
      300          let num_degrees = max_degree as usize - min_degree as usize;
        .          let mut outputs = Vec::with_capacity(num_degrees);
        .          let mut kernel = Vec::with_capacity(num_degrees);
        .          for i in 0..num_degrees {
        .              outputs.push(Once::new());
        .              kernel.push(Once::new());
        .          }
    1,700          Self {
        .              source,
        .              target,
        .              outputs,
        .              kernel,
        .              min_degree,
        .              degree_shift
        .          }
      800      }
        .  
  125,844      pub fn get_output(&self, generator_degree : i32, generator_index : usize ) -> &FpVector {
  503,376          assert!(generator_degree >= self.source.min_degree);
  251,688          assert!(generator_index < self.source.get_number_of_gens_in_degree(generator_degree));        
  251,688          let generator_degree_idx = (generator_degree - self.source.min_degree) as usize;
        .          return &self.outputs[generator_degree_idx].get()[generator_index];
  251,688      }
        .  
        .      // We don't actually mutate &mut matrix, we just slice it.
   60,000      pub fn add_generators_from_matrix_rows(&self, degree : i32, matrix : &mut Matrix, first_new_row : usize, first_target_column : usize, new_generators : usize){
        .          // println!("    add_gens_from_matrix degree : {}, first_new_row : {}, new_generators : {}", degree, first_new_row, new_generators);
   25,000          let dimension = self.target.get_dimension(degree);
      356  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/finite_dimensional_module.rs:<rust_ext::finite_dimensional_module::FiniteDimensionalModule as rust_ext::module::Module>::get_dimension (50x)
    5,000  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/module.rs:<rust_ext::module::ZeroModule as rust_ext::module::Module>::get_dimension (2500x)
   46,550  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/free_module.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::get_dimension (2450x)
        .          // println!("    dimension : {} target name : {}", dimension, self.target.get_name());
   25,000          assert!(degree >= self.source.min_degree);
        .          let degree_idx = (degree - self.source.min_degree) as usize;
        .          let p = self.get_prime();
   20,000          let dimension = self.target.get_dimension(degree + self.degree_shift);
    5,000  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/module.rs:<rust_ext::module::ZeroModule as rust_ext::module::Module>::get_dimension (2500x)
      356  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/finite_dimensional_module.rs:<rust_ext::finite_dimensional_module::FiniteDimensionalModule as rust_ext::module::Module>::get_dimension (50x)
   46,550  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/free_module.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::get_dimension (2450x)
        .          let mut new_outputs : Vec<FpVector> = Vec::with_capacity(new_generators);
        .          for _ in 0 .. new_generators {
    2,056              new_outputs.push(FpVector::new(p, dimension, 0));
   99,185  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::new (514x)
        .          }
   10,000          if dimension == 0 {
        .              self.outputs[degree_idx].set(new_outputs);
        .              return;
        .          }
      514          for i in 0 .. new_generators {
        .              let output_vector = &mut matrix[first_new_row + i];
        .              output_vector.set_slice(0, dimension);
      514              new_outputs[i].assign(&output_vector);
  138,363  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::assign (257x)
        .              output_vector.clear_slice();
        .          }
        .          self.outputs[degree_idx].set(new_outputs);
   40,000      }
        .  
        .      pub fn apply_to_basis_element_with_table(&self, result : &mut FpVector, coeff : u32, input_degree : i32, table : &FreeModuleTableEntry, input_index : usize){
  251,688          assert!(input_degree >= self.source.min_degree);
  251,688          assert!(input_index < table.basis_element_to_opgen.len());
  880,908          assert!(self.target.get_dimension(input_degree + self.degree_shift) == result.get_dimension());
1,156,454  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/free_module.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::get_dimension (60866x)
   14,392  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/finite_dimensional_module.rs:<rust_ext::finite_dimensional_module::FiniteDimensionalModule as rust_ext::module::Module>::get_dimension (2056x)
  125,844  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/module.rs:<rust_ext::module::ZeroModule as rust_ext::module::Module>::get_dimension (62922x)
        .          let operation_generator = &table.basis_element_to_opgen[input_index];
  251,688          let operation_degree = operation_generator.operation_degree;
  251,688          let operation_index = operation_generator.operation_index;
  125,844          let generator_degree = operation_generator.generator_degree;
  125,844          let generator_index = operation_generator.generator_index;
  377,532          let output_on_generator = self.get_output(generator_degree, generator_index);
5,411,292  => src/free_module_homomorphism.rs:rust_ext::free_module_homomorphism::FreeModuleHomomorphism::get_output (125844x)
1,510,128          self.target.act(result, coeff, operation_degree, operation_index, generator_degree + self.degree_shift, output_on_generator);
1,868,076,261  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/module.rs:rust_ext::module::Module::act (125844x)
        .      }
        .  
   55,000      pub fn get_matrix_with_table(&self, matrix : &mut Matrix, table : &FreeModuleTableEntry , degree : i32, start_row : usize, start_column : usize) -> (usize, usize) {
   20,000          let source_dimension = self.source.get_dimension_with_table(degree, table);
   25,000          let target_dimension = self.get_target().get_dimension(degree);
      356  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/finite_dimensional_module.rs:<rust_ext::finite_dimensional_module::FiniteDimensionalModule as rust_ext::module::Module>::get_dimension (50x)
    5,000  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/module.rs:<rust_ext::module::ZeroModule as rust_ext::module::Module>::get_dimension (2500x)
   46,550  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/free_module.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::get_dimension (2450x)
   10,000          assert!(source_dimension <= matrix.get_rows());
   10,000          assert!(target_dimension <= matrix.get_columns());
        .          for input_idx in 0 .. source_dimension {
        .              // Writing into slice.
        .              // Can we take ownership from matrix and then put back? 
        .              // If source is smaller than target, just allow add to ignore rest of input would work here.
        .              let output_vector = &mut matrix[start_row + input_idx];
        .              output_vector.set_slice(start_column, start_column + target_dimension);
        .              self.apply_to_basis_element_with_table(output_vector, 1, degree, table, input_idx);
        .              output_vector.clear_slice();
-- line 144 ----------------------------------------

1,418,723  <counts for unidentified lines in src/free_module_homomorphism.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs
--------------------------------------------------------------------------------
        Ir 

-- line 52 ----------------------------------------
         .      /// Initialization constant of `Once`.
         .      pub const INIT: Self = Once {
         .          state: AtomicUsize::new(INCOMPLETE),
         .          data: UnsafeCell::new(None),
         .      };
         .  
         .      /// Creates a new `Once` value.
         .      pub const fn new() -> Once<T> {
    85,800          Self::INIT
         .      }
         .  
         .      fn force_get<'a>(&'a self) -> &'a T {
 3,853,224          match unsafe { &*self.data.get() }.as_ref() {
         .              None    => unsafe { unreachable() },
 2,474,840              Some(p) => p,
         .          }
         .      }
         .  
         .      /// Performs an initialization routine once and only once. The given closure
         .      /// will be executed if this is the first time `call_once` has been called,
         .      /// and otherwise the routine will *not* be invoked.
         .      ///
         .      /// This method will block the calling thread if another initialization
-- line 74 ----------------------------------------
-- line 95 ----------------------------------------
         .      /// # 2
         .      /// }
         .      /// ```
         .      pub fn call_once<'a, F>(&'a self, builder: F) -> &'a T
         .          where F: FnOnce() -> T
         .      {
         .          let mut status = self.state.load(Ordering::SeqCst);
         .  
    20,400          if status == INCOMPLETE {
         .              status = self.state.compare_and_swap(INCOMPLETE,
         .                                                   RUNNING,
         .                                                   Ordering::SeqCst);
    10,200              if status == INCOMPLETE { // We init
         .                  // We use a guard (Finish) to catch panics caused by builder
    15,200                  let mut finish = Finish { state: &self.state, panicked: true };
    99,350                  unsafe { *self.data.get() = Some(builder()) };
   145,000  => /build/glibc-OTsEL5/glibc-2.27/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (5000x)
    12,650                  finish.panicked = false;
         .  
         .                  status = COMPLETE;
         .                  self.state.store(status, Ordering::SeqCst);
         .  
         .                  // This next line is strictly an optomization
         .                  return self.force_get();
         .              }
         .          }
-- line 119 ----------------------------------------
-- line 130 ----------------------------------------
         .                  _ => unsafe { unreachable() },
         .              }
         .          }
         .      }
         .  
         .      /// Returns a pointer iff the `Once` was previously initialized
         .      pub fn try<'a>(&'a self) -> Option<&'a T> {
         .          match self.state.load(Ordering::SeqCst) {
11,209,523              COMPLETE => Some(self.force_get()),
         .              _        => None,
         .          }
         .      }
         .  
         .      /// Like try, but will spin if the `Once` is in the process of being
         .      /// initialized
         .      pub fn wait<'a>(&'a self) -> Option<&'a T> {
         .          loop {
-- line 146 ----------------------------------------

     7,700  <counts for unidentified lines in /home/hood/.cargo/registry/src/github.com-1ecc6299db9ec823/spin-0.5.0/src/once.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/module.rs
--------------------------------------------------------------------------------
       Ir 

-- line 2 ----------------------------------------
        .  use crate::algebra::Algebra;
        .  
        .  // enum Module_Type {
        .  
        .  // }
        .  
        .  pub trait Module {
        .      fn get_prime(&self) -> u32 {
   20,001          self.get_algebra().get_prime()
        2  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_prime (1x)
        .      }
        .      fn get_algebra(&self) -> &Algebra;
        .      fn get_name(&self) -> &str;
        .      // fn get_type() -> Module_Type;
        .      // int min_degree;
        .      // int max_degree; // Rename to max_allocated_degree?
        .      // int max_computed_degree;
        .  // Methods:
        .      fn get_min_degree(&self) -> i32;
        .      // fn get_max_degree(&self) -> i32;
        .      fn compute_basis(&mut self, _degree : i32) {}
        .      fn get_dimension(&self, degree : i32) -> usize;
        .      fn act_on_basis(&self, result : &mut FpVector, coeff : u32, op_degree : i32, op_index : usize, mod_degree : i32, mod_index : usize);
        .      fn basis_element_to_string(&self, degree : i32, idx : usize) -> String;
        .  
1,006,752      fn act(&self, result : &mut FpVector, coeff : u32, op_degree : i32, op_index : usize, input_degree : i32, input : &FpVector){
  251,688          assert!(input.get_dimension() == self.get_dimension(input_degree));
  312,554          let p = self.get_algebra().get_prime();
  251,688  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_prime (125844x)
        .          for (i, v) in input.iter().enumerate() {
2,666,530              if v == 0 {
        .                  continue;
        .              }
2,737,200              self.act_on_basis(result, (coeff * v) % p, op_degree, op_index, input_degree, i);
  150,088  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/finite_dimensional_module.rs:<rust_ext::finite_dimensional_module::FiniteDimensionalModule as rust_ext::module::Module>::act_on_basis (2056x)
1,778,645,725  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/free_module.rs:<rust_ext::free_module::FreeModule as rust_ext::module::Module>::act_on_basis (271664x)
        .          }
  503,376      }
        .  
        .      fn element_to_string(&self, degree : i32, element : &FpVector) -> String {
        .          let mut result = String::new();
        .          let mut zero = true;
        .          for (idx, value) in element.iter().enumerate() {
        .              if value == 0 {
        .                  continue;
        .              }
-- line 43 ----------------------------------------
-- line 59 ----------------------------------------
        .          return result;
        .      } 
        .  }
        .  
        .  pub struct ZeroModule<'a> {algebra : &'a Algebra, name : String }
        .  
        .  impl<'a> ZeroModule<'a> {
        .      pub fn new(algebra : &'a Algebra) -> Self {
       16          let name = format!("Zero Module over {}", algebra.get_name());
      954  => /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c//src/liballoc/fmt.rs:alloc::fmt::format (2x)
        6  => /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_name (2x)
        7          ZeroModule {
        .              algebra,
        .              name
        .          }
        .      }
        .  }
        .  
        .  impl<'a> Module for ZeroModule<'a> {
        .      fn get_algebra(&self) -> &Algebra {
  125,844          self.algebra
        .      }
        .      
        .      fn get_name(&self) -> &str{
        .          return &self.name;
        .      }
        .  
        .      fn get_dimension(&self, _degree : i32) -> usize {
        .          0
  145,844      }
        .  
        .      fn get_min_degree(&self) -> i32 {
        .          0
        .      }
        .  
        .      // Since the dimension is 0, the input of this function is an element of the basis which is the empty set.
        .      fn act_on_basis(&self, _result : &mut FpVector, _coeff : u32, _op_degree : i32, _op_index : usize, _mod_degree : i32, _mod_index : usize){
        .          assert!(false);
-- line 94 ----------------------------------------

  336,643  <counts for unidentified lines in src/module.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/free_module.rs
--------------------------------------------------------------------------------
       Ir 

-- line 27 ----------------------------------------
        .  
        .  impl<'a> Module for FreeModule<'a> {
        .  
        .      fn get_name(&self) -> &str {
        .          &self.name
        .      }
        .  
        .      fn get_algebra(&self) -> &Algebra {
1,884,216          self.algebra
        .      }
        .  
        .      fn get_min_degree(&self) -> i32 {
    4,950          self.min_degree
        .      }
        .  
   70,666      fn get_dimension(&self, degree : i32) -> usize {
        .          // println!("Get dimension of {} in degree {}", self.name, degree);
1,209,588          if degree < self.min_degree {
        .              return 0;
        .          }
  595,594          let degree_idx = (degree - self.min_degree) as usize;
        .          return self.table[degree_idx].get().basis_element_to_opgen.len();
  141,332      }
        .  
        .      fn basis_element_to_string(&self, degree : i32, idx : usize) -> String {
        .          let opgen = self.index_to_op_gen(degree, idx);
        .          let mut op_str = self.algebra.basis_element_to_string(opgen.operation_degree, opgen.operation_index);
        .          if &*op_str == "1" {
        .              op_str = "".to_string();
        .          } else {
        .              op_str.push(' ');
        .          }
        .          return format!("{}x_{{{},{}}}", op_str, opgen.generator_degree, opgen.generator_index);
        .      }
        .  
3,259,968      fn act_on_basis(&self, result : &mut FpVector, coeff : u32, op_degree : i32, op_index : usize, mod_degree : i32, mod_index : usize){
1,358,320          assert!(op_index < self.get_algebra().get_dimension(op_degree, mod_degree));
4,618,288  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension (271664x)
  814,992          assert!(self.get_dimension(op_degree + mod_degree) <= result.get_dimension());
        .          let operation_generator = self.index_to_op_gen(mod_degree, mod_index);
  543,328          let module_operation_degree = operation_generator.operation_degree;
  271,664          let module_operation_index = operation_generator.operation_index;
  271,664          let generator_degree = operation_generator.generator_degree; 
  271,664          let generator_index  = operation_generator.generator_index;
        .  
        .  
        .          // Now all of the output elements are going to be of the form s * x. Find where such things go in the output vector.
1,629,984          let num_ops = self.get_algebra().get_dimension(module_operation_degree + op_degree, generator_degree);
4,618,288  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension (271664x)
1,629,984          let output_block_min = self.operation_generator_to_index(module_operation_degree + op_degree, 0, generator_degree, generator_index);
10,323,232  => src/free_module.rs:rust_ext::free_module::FreeModule::operation_generator_to_index (271664x)
  271,664          let output_block_max = output_block_min + num_ops;
        .          // Writing into slice (can we take ownership? make new vector with 0's outside range and add separately? is it okay?)
        .          result.set_slice(output_block_min, output_block_max); 
        .          // Now we multiply s * r and write the result to the appropriate position.
2,988,304          self.get_algebra().multiply_basis_elements(result, coeff, op_degree, op_index, module_operation_degree, module_operation_index, generator_degree);
1,727,301,229  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::multiply_basis_elements (271664x)
        .          result.clear_slice();
2,173,312      }
        .  }
        .  
        .  impl<'a> FreeModule<'a> {
        .      pub fn new(algebra : &'a Algebra, name : String, min_degree : i32, max_degree : i32) -> Self {
        .          let number_of_degrees = (max_degree - min_degree) as usize;
        .          let mut table = Vec::with_capacity(number_of_degrees);
        .          for _ in 0..number_of_degrees {
        .              table.push(Once::new());
        .          }
      900          Self {
        .              algebra,
        .              name,
        .              min_degree,
        .              max_degree,
        .              table
        .          }
        .      }
        .  
        .      pub fn get_number_of_gens_in_degree(&self, degree : i32) -> usize {
  258,825          if degree < self.min_degree {
        .              return 0;
        .          }
  447,557          let degree_idx = (degree - self.min_degree) as usize;
   65,025          return self.table[degree_idx].get().num_gens;
        .      }
        .  
        .      pub fn construct_table(&self, degree : i32) -> FreeModuleTableEntry {
   10,000          assert!(degree >= self.min_degree);
    5,000          let degree_idx = (degree - self.min_degree) as usize;
    2,500          let mut basis_element_to_opgen : Vec<OperationGeneratorPair> = Vec::with_capacity(degree_idx + 1);
        .          let mut generator_to_index : Vec<Vec<usize>> = Vec::with_capacity(degree_idx + 1);
        .          // gen_to_idx goes gen_degree => gen_idx => start of block.
        .          // so gen_to_idx_size should be (number of possible degrees + 1) * sizeof(uint*) + number of gens * sizeof(uint).
        .          // The other part of the table goes idx => opgen
        .          // The size should be (number of basis elements in current degree) * sizeof(FreeModuleOperationGeneratorPair)
        .          // A basis element in degree n comes from a generator in degree i paired with an operation in degree n - i.
        .          let mut offset = 0;
        .          for gen_deg in self.min_degree .. degree {
        .              let num_gens = self.get_number_of_gens_in_degree(gen_deg);
        .              let mut gentoidx_degree : Vec<usize> = Vec::with_capacity(num_gens);
  122,500              let op_deg = degree - gen_deg;
  183,750              let num_ops = self.get_algebra().get_dimension(op_deg, gen_deg);
1,041,250  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/adem_algebra.rs:<rust_ext::adem_algebra::AdemAlgebra as rust_ext::algebra::Algebra>::get_dimension (61250x)
        .              for gen_idx in 0 .. num_gens {
        .                  gentoidx_degree.push(offset);
        .                  for op_idx in 0 .. num_ops {
        .                      basis_element_to_opgen.push(OperationGeneratorPair {
        .                          generator_degree : gen_deg,
        .                          generator_index : gen_idx,
        .                          operation_degree : op_deg,
        .                          operation_index : op_idx
        .                      })
        .                  }
    4,319                  offset += num_ops;
        .              }
  245,000              generator_to_index.push(gentoidx_degree);
        .          }
   30,000          FreeModuleTableEntry {
        .              num_gens : 0,
        .              basis_element_to_opgen,
        .              generator_to_index
        .          }
        .      }
        .  
        .      pub fn get_dimension_with_table(&self, degree : i32, table : &FreeModuleTableEntry) -> usize {
        .          // println!("Get dimension of {} in degree {}", self.name, degree);
   22,500          if degree < self.min_degree {
        .              return 0;
        .          }
        .          let degree_idx = (degree - self.min_degree) as usize;
        .          return table.basis_element_to_opgen.len();
        .      }
        .  
        .      pub fn add_generators(&self, degree : i32, mut table : FreeModuleTableEntry,  num_gens : usize){
    7,500          assert!(degree >= self.min_degree);
    7,500          let degree_idx = (degree - self.min_degree) as usize;
        .          Self::add_generators_to_table(degree, &mut table, num_gens);
   30,000          self.table[degree_idx].set(table);
  115,000  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/once.rs:rust_ext::once::Once<T>::set (2500x)
        .      }
        .  
        .      fn add_generators_to_table(degree : i32, table : &mut FreeModuleTableEntry, num_gens : usize){
        .          // let old_num_gens = table.num_gens;
        .          // let new_num_gens = old_num_gens + new_generators;
    2,500          table.num_gens = num_gens;
        .          let old_dimension = table.basis_element_to_opgen.len();
        .          let mut start_of_block = old_dimension;
        .          let mut gen_to_idx = Vec::with_capacity(num_gens);
        .          for gen_idx in 0 .. num_gens {
        .              table.basis_element_to_opgen.push(OperationGeneratorPair {
        .                  generator_degree : degree,
        .                  generator_index : gen_idx,
        .                  operation_degree : 0,
        .                  operation_index : 0
        .              });
        .              gen_to_idx.push(start_of_block);
        .              start_of_block += 1;
        .          }
   15,000          table.generator_to_index.push(gen_to_idx);
        .      }
        .  
  271,664      pub fn operation_generator_to_index(&self, op_deg : i32, op_idx : usize, gen_deg : i32, gen_idx : usize) -> usize {
  543,328          assert!(op_deg >= 0);
  814,992          assert!(gen_deg >= self.min_degree);
  814,992          let out_deg_idx = (op_deg + gen_deg - self.min_degree) as usize;
        .          let gen_deg_idx = (gen_deg - self.min_degree) as usize;
  271,664          return self.table[out_deg_idx].get().generator_to_index[gen_deg_idx][gen_idx] + op_idx;
  543,328      }
        .  
        .      pub fn index_to_op_gen(&self, degree : i32, index : usize) -> &OperationGeneratorPair {
  814,992          assert!(degree >= self.min_degree);
  543,328          let degree_idx = (degree - self.min_degree) as usize;
        .          return &self.table[degree_idx].get().basis_element_to_opgen[index];
        .      }
        .  }
        .  
        .  #[cfg(test)]
        .  mod tests {
        .      #![allow(non_snake_case)]
        .  
-- line 199 ----------------------------------------

2,538,776  <counts for unidentified lines in src/free_module.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/matrix.rs
--------------------------------------------------------------------------------
        Ir 

-- line 14 ----------------------------------------
         .      slice_row_end : usize,
         .      slice_col_start : usize,
         .      slice_col_end : usize,
         .      vectors : CVec<FpVector>,
         .      row_permutation : CVec<usize>
         .  }
         .  
         .  impl Matrix {
    55,000      pub fn new(p : u32, rows : usize, columns : usize) -> Matrix {
         .          let mut vectors : Vec<FpVector> = Vec::with_capacity(rows);
         .          for _ in 0..rows {
   420,116              vectors.push(FpVector::new(p, columns, 0));
39,111,284  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::new (105029x)
         .          }
         .          let mut permutation : Vec<usize> = Vec::with_capacity(columns);
         .          for i in 0..rows {
         .              permutation.push(i);
         .          }
    85,000          Matrix { 
         .              p, rows, columns, 
         .              slice_row_start : 0, slice_row_end : rows,
         .              slice_col_start : 0, slice_col_end : columns,
    10,000              vectors : CVec::from_vec(vectors), 
    12,502              row_permutation : CVec::from_vec(permutation) 
         .          }
    40,000      }
         .  
         .      pub fn new_from_allocator<T : MemoryAllocator + std::fmt::Display>(allocator: &T, p : u32, rows : usize, columns : usize) -> Matrix {
         .          let mut vectors : CVec<FpVector> = allocator.alloc_vec(rows);
         .          for v in vectors.iter_mut() {
         .              *v = FpVector::new_from_allocator(allocator, p, columns, 0);
         .          }
         .          let mut row_permutation : CVec<usize> = allocator.alloc_vec(rows);
         .          for i in 0..rows {
-- line 46 ----------------------------------------
-- line 51 ----------------------------------------
         .              slice_row_start : 0, slice_row_end : rows,
         .              slice_col_start : 0, slice_col_end : columns,
         .              vectors, 
         .              row_permutation,  
         .          }
         .      }
         .  
         .      pub fn get_rows(&self) -> usize {
    35,000          self.slice_row_end - self.slice_row_start
         .      }
         .  
         .      pub fn get_columns(&self) -> usize {
    25,000          self.slice_col_end - self.slice_col_start
         .      }
         .  
         .      pub fn set_slice(&mut self, row_start : usize, row_end : usize, col_start : usize, col_end : usize) {
         .          for v in self.vectors.iter_mut() {
         .              v.set_slice(col_start, col_end);
         .          }
     2,500          self.slice_row_start = row_start;
     2,500          self.slice_row_end = row_end;
     2,500          self.slice_col_start = col_start;
     7,500          self.slice_col_end = col_end;
         .      }
         .  
         .      pub fn clear_slice(&mut self) {
         .          for v in self.vectors.iter_mut() {
         .              v.clear_slice();
         .          }        
     2,500          self.slice_row_start = 0;
     5,000          self.slice_row_end = self.rows;
     2,500          self.slice_col_start = 0;
     7,500          self.slice_col_end = self.columns;
         .      }
         .  }
         .  
         .  impl std::ops::Deref for Matrix {
         .      type Target = [FpVector];
         .  
         .      fn deref(&self) -> &[FpVector] {
         .          &*self.vectors
-- line 91 ----------------------------------------
-- line 142 ----------------------------------------
         .          write!(f,"\n]")?;
         .          Ok(())
         .      }
         .  }
         .  
         .  impl std::ops::Index<usize> for Matrix {
         .      type Output = FpVector;
         .      fn index(&self, i : usize) -> &Self::Output {
    63,434          &self.vectors[self.slice_row_start + i]
         .      }
         .  }
         .  
         .  impl std::ops::IndexMut<usize> for Matrix {
         .      fn index_mut(&mut self, i : usize) -> &mut Self::Output {
 2,718,177          &mut self.vectors[self.slice_row_start + i]
         .      }
         .  }
         .  
         .  // void Matrix_serialize(char **buffer, Matrix *M){
         .  //     size_t size = Matrix_getSize(M->p, M->rows, M->columns);
         .  //     memcpy(*buffer, M, sizeof(Matrix));
         .  //     *buffer += sizeof(Matrix);
         .  //     *buffer += M->rows * sizeof(Vector*);
-- line 164 ----------------------------------------
-- line 224 ----------------------------------------
         .  //         temp[i] = M->vectors[permutation[i]];
         .  //     }
         .  //     memcpy(M->vectors, temp, rows * sizeof(Vector*));
         .  // }
         .  
         .  
         .  impl Matrix {
         .      pub fn swap_rows(&mut self, i : usize, j : usize){
   125,844          self.vectors.swap(i + self.slice_row_start, j + self.slice_row_start);
   188,766          self.row_permutation.swap(i + self.slice_row_start, j + self.slice_row_start);
   188,766  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/memory.rs:<rust_ext::memory::CVec<T> as core::ops::deref::DerefMut>::deref_mut (62922x)
         .      }
         .  
         .      pub fn apply_permutation(&mut self, permutation : CVec<usize>, scratch_space : CVec<FpVector>){
         .          self.vectors.apply_permutation(permutation, scratch_space);
         .      }
         .  
         .      pub fn row_op(&mut self, target : usize, source : usize, coeff : u32){
         .          unsafe {
         .              // Can't take two mutable loans from one vector, so instead just cast
         .              // them to their raw pointers to do the swap
         .              let ptarget: *mut FpVector = &mut self[target];
         .              let psource: *const FpVector = &mut self[source];
 1,327,499              (*ptarget).add(&*psource, coeff);
1,095,747,457  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::add (1327499x)
         .          }
         .      }
         .  
    17,500      pub fn row_reduce(&mut self, column_to_pivot_row: &mut CVec<isize>){
     5,000          assert!(self.get_columns() <= column_to_pivot_row.len());
     2,500          let p = self.p;
         .          let columns = self.get_columns();
         .          let rows = self.get_rows();
         .          for x in column_to_pivot_row.iter_mut() {
     2,648              *x = -1;
   789,881  => /build/glibc-OTsEL5/glibc-2.27/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms (1324x)
         .          }
     5,000          if rows == 0 {
         .              return;
         .          }
         .          let mut pivot : usize = 0;
         .          for pivot_column in 0 .. columns {
         .              // Search down column for a nonzero entry.
         .              let mut pivot_row = rows;
 8,187,131              for i in pivot..rows {
31,363,430                  if self[i].get_entry(pivot_column) != 0 {
422,556,858  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_entry (7825127x)
         .                      pivot_row = i;
         .                      break;
         .                  }
         .              }
   424,926              if pivot_row == rows {
         .                  continue;
         .              }
         .  
         .              // Record position of pivot.
    62,922              column_to_pivot_row[pivot_column] = pivot as isize;
         .  
         .              // Pivot_row contains a row with a pivot in current column.
         .              // Swap pivot row up.
         .              self.swap_rows(pivot, pivot_row);
         .              // println!("({}) <==> ({}): \n{}", pivot, pivot_row, self);
         .  
         .              // // Divide pivot row by pivot entry
   188,766              let c = self[pivot].get_entry(pivot_column);
 3,397,788  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_entry (62922x)
         .              let c_inv = combinatorics::inverse(p, c);
         .              self[pivot].scale(c_inv);
         .              // println!("({}) <== {} * ({}): \n{}", pivot, c_inv, pivot, self);
         .  
         .              // if(col_end > 0){
         .              //     printf("row(%d) *= %d\n", pivot, c_inv);
         .              //     Matrix_printSlice(M, col_end, col_start);
         .              // }
         .              for i in 0 .. rows {
         .                  // Between pivot and pivot_row, we already checked that the pivot column is 0, so we could skip ahead a bit.
         .                  // But Rust doesn't make this as easy as C.
33,682,852                  if i == pivot {
         .                      // i = pivot_row;
         .                      continue;
         .                  }
33,557,008                  let pivot_column_entry = self[i].get_entry(pivot_column);
906,039,216  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::get_entry (16778504x)
33,557,008                  if pivot_column_entry == 0 {
         .                      continue;
         .                  }
         .                  let row_op_coeff = p - pivot_column_entry;
         .                  // Do row operation
         .                  self.row_op(i, pivot, row_op_coeff);
         .              }
   125,844              pivot += 1;
         .          }
         .          return;
    20,000      }
         .  }
         .  
         .  pub struct Subspace {
         .      pub matrix : Matrix,
         .      pub column_to_pivot_row : CVec<isize>
         .  }
         .  
         .  impl Subspace {
         .      pub fn new(p : u32, rows : usize, columns : usize) -> Self {
    17,500          Self {
    72,500  => /build/glibc-OTsEL5/glibc-2.27/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms (2500x)
     5,000              matrix : Matrix::new(p, rows, columns),
11,976,606  => src/matrix.rs:rust_ext::matrix::Matrix::new (2500x)
         .              column_to_pivot_row : CVec::new(columns)
         .          }
         .      }
         .  
         .      pub fn entire_space(p : u32, dim : usize) -> Self {
         .          let mut result = Self::new(p, dim, dim);
         .          for i in 0..dim {
         .              result.matrix[i].set_entry(i, 1);
-- line 330 ----------------------------------------
-- line 335 ----------------------------------------
         .  }
         .  
         .  
         .  impl Matrix {
         .  
         .      /// matrix -- a row reduced augmented matrix
         .      /// column_to_pivot_row -- the pivots in matrix (also returned by row_reduce)
         .      /// first_source_column -- which block of the matrix is the source of the map
    20,000      pub fn compute_kernel(&mut self, first_source_column : usize, column_to_pivot_row : &CVec<isize>) -> Subspace {
     2,500          let p = self.p;
         .          let rows = self.get_rows();
         .          let columns = self.get_columns();
     5,000          let source_dimension = columns - first_source_column;
         .  
         .          // Find the first kernel row
         .          let mut first_kernel_row = rows;
    10,110          for i in first_source_column .. columns {
    16,508              if column_to_pivot_row[i] >= 0 {
         .                  first_kernel_row = column_to_pivot_row[i] as usize;
         .                  break;
         .              }
         .          }
         .          // Every row after the first kernel row is also a kernel row, so now we know how big it is and can allocate space.
     2,500          let kernel_dimension = rows - first_kernel_row;
         .          let mut kernel = Subspace::new(p, kernel_dimension, source_dimension);
     5,000          if kernel_dimension == 0 {
         .              for i in 0..source_dimension {
        48                  kernel.column_to_pivot_row[i] = -1;
         .              }
         .              return kernel;
         .          }
         .          // Write pivots into kernel
         .          for i in 0 .. source_dimension {
         .              // Turns -1 into some negative number... make sure to check <0 for no pivot in column...
   251,496              kernel.column_to_pivot_row[i] = column_to_pivot_row[i + first_source_column] - first_kernel_row as isize;
         .          }
         .          // Copy kernel matrix into kernel
    66,712          for row in 0 .. kernel_dimension {
         .              // Reading from slice, alright.
         .              let vector = &mut self[first_kernel_row + row];
         .              vector.set_slice(first_source_column, first_source_column + source_dimension);
    63,178              kernel.matrix[row].assign(&vector);
19,481,967  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::assign (31589x)
         .              vector.clear_slice();
         .          }
         .          return kernel;
    20,000      }
         .  
         .      /// Take an augmented row reduced matrix representation of a map and adds rows to it to hit the complement
         .      /// of complement_pivots in desired_image. Does so by walking through the columns and if it finds a target column
         .      /// that has a pivot in desired_image but no pivot in current_pivots or complement_pivots, add that the row in desired_image
         .      /// to the matrix.
         .      ///    self -- An augmented, row reduced matrix to be modified to extend it's image.
         .      ///    first_source_column : Where does the source comppstart in the augmented matrix?
         .      pub fn get_image(&mut self, image_rows : usize, target_dimension : usize, pivots : &CVec<isize>) -> Subspace {
-- line 388 ----------------------------------------
-- line 401 ----------------------------------------
         .      pub fn extend_to_surjection(&mut self, 
         .          mut first_empty_row : usize, 
         .          start_column : usize, end_column : usize,        
         .          current_pivots : &CVec<isize>, complement_pivots : Option<&CVec<isize>>
         .      ) -> usize {
         .          // println!("extend_to_surjection start_column = {} end_column = {}", start_column, end_column);
         .          let mut homology_dimension = 0;
         .          for i in start_column .. end_column {
         2              if current_pivots[i] >= 0 {
         .                  continue;
         .              }
         .              if let Some(l) = &complement_pivots {
         .                  if l[i - start_column] >= 0 { continue; }
         .              }
         .              // Look up the cycle that we're missing and add a generator hitting it.
         .              let matrix_row = &mut self[first_empty_row];
         .              // Writing into slice -- leaving rest of Vector alone would be alright in this case.
         2              matrix_row.set_to_zero();
       397  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::set_to_zero (1x)
         5              matrix_row.set_entry(i, 1);
        60  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::set_entry (1x)
         1              first_empty_row += 1;
         1              homology_dimension += 1;
         .          }
         .          return homology_dimension;
         .      }
         .  
         .      pub fn extend_image_to_desired_image(&mut self, 
         .          mut first_empty_row : usize,
         .          start_column : usize, end_column : usize,
         .          current_pivots : &CVec<isize>, desired_image : &Subspace, 
         .          complement_pivots : Option<&CVec<isize>>
         .      ) -> usize {
         .          let mut homology_dimension = 0;
         .          let desired_pivots = &desired_image.column_to_pivot_row;
     2,450          let early_end_column = std::cmp::min(end_column, desired_pivots.len() + start_column);
         .          for i in start_column .. early_end_column {
   188,510              assert!(current_pivots[i] < 0 || desired_pivots[i - start_column] >= 0);
    63,178              if current_pivots[i] >= 0 || desired_pivots[i - start_column] < 0 {
         .                  continue;
         .              }
         .              if let Some(l) = &complement_pivots {
         .                  if l[i - start_column] >= 0 { continue; }
         .              }
         .              // Look up the cycle that we're missing and add a generator hitting it.
         .              let kernel_vector_row = desired_pivots[i] as usize;
         .              let new_image = &desired_image.matrix[kernel_vector_row];
         .              let matrix_row = &mut self[first_empty_row];
         .              // Writing into slice -- leaving rest of Vector alone would be alright in this case.
       256              matrix_row.set_slice(0, desired_image.matrix.columns);
       512              matrix_row.assign(&new_image);
   137,758  => /mnt/c/Users/Hood/Documents/programming/rust_ext/src/fp_vector.rs:rust_ext::fp_vector::FpVector::assign (256x)
         .              matrix_row.clear_slice();
       256              first_empty_row += 1;
       256              homology_dimension += 1;
         .          }
         .          return homology_dimension;
         .      }
         .  
         .      /// Take an augmented row reduced matrix representation of a map and adds rows to it to hit the complement
         .      /// of complement_pivots in desired_image. Does so by walking through the columns and if it finds a target column
         .      /// that has a pivot in desired_image but no pivot in current_pivots or complement_pivots, add that the row in desired_image
         .      /// to the matrix.
         .      ///    self -- An augmented, row reduced matrix to be modified to extend it's image.
         .      ///    first_source_column : Where does the source comppstart in the augmented matrix?
    55,000      pub fn extend_image(&mut self, 
         .          first_empty_row : usize, 
         .          start_column : usize, end_column : usize, 
         .          current_pivots : &CVec<isize>, desired_image : Option<&Subspace>, 
         .          complement_pivots : Option<&CVec<isize>>
         .      ) -> usize {
         .          // println!("desired_image : {:?} ", desired_image.map(|subspace| &subspace.matrix));
    10,000          if let Some(image) = desired_image {
         .              // println!("desired_image pivots : {:?} ", &*image.column_to_pivot_row);
         .              // println!("start_col : {}, end_col : {}", start_column, end_column);
         .              return self.extend_image_to_desired_image(first_empty_row, start_column, end_column, current_pivots, image, complement_pivots);
         .          } else {
         .              return self.extend_to_surjection(first_empty_row, start_column, end_column, current_pivots, complement_pivots);
         .          }
    40,000      }
         .  }
         .  
         .  pub struct QuasiInverse<'a> {
         .      pub matrix : Matrix,
         .      pub image : &'a Subspace
         .  }
         .  
         .  impl QuasiInverse<'_> {
-- line 485 ----------------------------------------

17,703,174  <counts for unidentified lines in src/matrix.rs>

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /build/glibc-OTsEL5/glibc-2.27/malloc/malloc.c
  /build/glibc-OTsEL5/glibc-2.27/string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S
  /cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.4.0/src/raw/bitmask.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/hash/mod.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/cmp.rs
  /cargo/registry/src/github.com-1ecc6299db9ec823/hashbrown-0.4.0/src/raw/mod.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/ptr.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c//src/libstd/sys/unix/alloc.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/num/mod.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/sync/atomic.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/vec.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/hash/sip.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/option.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/liballoc/raw_vec.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/slice/mod.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libstd/collections/hash/map.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/iter/range.rs
  /build/glibc-OTsEL5/glibc-2.27/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/intrinsics.rs
  /rustc/a53f9df32fbb0b5f4382caaad8f1a46f36ea887c/src/libcore/../stdsimd/crates/core_arch/src/x86/sse2.rs

--------------------------------------------------------------------------------
Ir 
--------------------------------------------------------------------------------
69  percentage of events annotated

