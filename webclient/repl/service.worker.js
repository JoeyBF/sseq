/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/service.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/mustache/mustache.js":
/*!*******************************************!*\
  !*** ./node_modules/mustache/mustache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file has been generated from mustache.mjs\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, (function () { 'use strict';\n\n  /*!\n   * mustache.js - Logic-less {{mustache}} templates with JavaScript\n   * http://github.com/janl/mustache.js\n   */\n\n  var objectToString = Object.prototype.toString;\n  var isArray = Array.isArray || function isArrayPolyfill (object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction (object) {\n    return typeof object === 'function';\n  }\n\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n  function typeStr (obj) {\n    return isArray(obj) ? 'array' : typeof obj;\n  }\n\n  function escapeRegExp (string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n  function hasProperty (obj, propName) {\n    return obj != null && typeof obj === 'object' && (propName in obj);\n  }\n\n  /**\n   * Safe way of detecting whether or not the given thing is a primitive and\n   * whether it has the given property\n   */\n  function primitiveHasOwnProperty (primitive, propName) {\n    return (\n      primitive != null\n      && typeof primitive !== 'object'\n      && primitive.hasOwnProperty\n      && primitive.hasOwnProperty(propName)\n    );\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var regExpTest = RegExp.prototype.test;\n  function testRegExp (re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace (string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml (string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   *\n   * Tokens for partials also contain two more elements: 1) a string value of\n   * indendation prior to that tag and 2) the index of that tag on that line -\n   * eg a value of 2 indicates the partial is the third tag on this line.\n   */\n  function parseTemplate (template, tags) {\n    if (!template)\n      return [];\n    var lineHasNonSpace = false;\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n    var indentation = '';  // Tracks indentation for tags that use it\n    var tagIndex = 0;      // Stores a count of number of tags encountered on a line\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace () {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags (tagsToCompile) {\n      if (typeof tagsToCompile === 'string')\n        tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n        throw new Error('Invalid tags: ' + tagsToCompile);\n\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n            indentation += chr;\n          } else {\n            nonSpace = true;\n            lineHasNonSpace = true;\n            indentation += ' ';\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n') {\n            stripSpace();\n            indentation = '';\n            tagIndex = 0;\n            lineHasNonSpace = false;\n          }\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      if (type == '>') {\n        token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\n      } else {\n        token = [ type, value, start, scanner.pos ];\n      }\n      tagIndex++;\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    stripSpace();\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens (tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens (tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner (string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function eos () {\n    return this.tail === '';\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function scan (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function scanUntil (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n      case 0:\n        match = '';\n        break;\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context (view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function push (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function lookup (name) {\n    var cache = this.cache;\n\n    var value;\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this, intermediateValue, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          intermediateValue = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           *\n           * In the case where dot notation is used, we consider the lookup\n           * to be successful even if the last \"object\" in the path is\n           * not actually an object but a primitive (e.g., a string, or an\n           * integer), because it is sometimes useful to access a property\n           * of an autoboxed primitive, such as the length of a string.\n           **/\n          while (intermediateValue != null && index < names.length) {\n            if (index === names.length - 1)\n              lookupHit = (\n                hasProperty(intermediateValue, names[index])\n                || primitiveHasOwnProperty(intermediateValue, names[index])\n              );\n\n            intermediateValue = intermediateValue[names[index++]];\n          }\n        } else {\n          intermediateValue = context.view[name];\n\n          /**\n           * Only checking against `hasProperty`, which always returns `false` if\n           * `context.view` is not an object. Deliberately omitting the check\n           * against `primitiveHasOwnProperty` if dot notation is not used.\n           *\n           * Consider this example:\n           * ```\n           * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n           * ```\n           *\n           * If we were to check also against `primitiveHasOwnProperty`, as we do\n           * in the dot notation case, then render call would return:\n           *\n           * \"The length of a football field is 9.\"\n           *\n           * rather than the expected:\n           *\n           * \"The length of a football field is 100 yards.\"\n           **/\n          lookupHit = hasProperty(context.view, name);\n        }\n\n        if (lookupHit) {\n          value = intermediateValue;\n          break;\n        }\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer () {\n    this.templateCache = {\n      _cache: {},\n      set: function set (key, value) {\n        this._cache[key] = value;\n      },\n      get: function get (key) {\n        return this._cache[key];\n      },\n      clear: function clear () {\n        this._cache = {};\n      }\n    };\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function clearCache () {\n    if (typeof this.templateCache !== 'undefined') {\n      this.templateCache.clear();\n    }\n  };\n\n  /**\n   * Parses and caches the given `template` according to the given `tags` or\n   * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function parse (template, tags) {\n    var cache = this.templateCache;\n    var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n    var isCacheEnabled = typeof cache !== 'undefined';\n    var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n    if (tokens == undefined) {\n      tokens = parseTemplate(template, tags);\n      isCacheEnabled && cache.set(cacheKey, tokens);\n    }\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   *\n   * If the optional `tags` argument is given here it must be an array with two\n   * string values: the opening and closing tags used in the template (e.g.\n   * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n   */\n  Writer.prototype.render = function render (template, view, partials, tags) {\n    var tokens = this.parse(template, tags);\n    var context = (view instanceof Context) ? view : new Context(view, undefined);\n    return this.renderTokens(tokens, context, partials, template, tags);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, tags) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this.renderPartial(token, context, partials, tags);\n      else if (symbol === '&') value = this.unescapedValue(token, context);\n      else if (symbol === 'name') value = this.escapedValue(token, context);\n      else if (symbol === 'text') value = this.rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender (template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\n    var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n    var partialByNl = partial.split('\\n');\n    for (var i = 0; i < partialByNl.length; i++) {\n      if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n        partialByNl[i] = filteredIndentation + partialByNl[i];\n      }\n    }\n    return partialByNl.join('\\n');\n  };\n\n  Writer.prototype.renderPartial = function renderPartial (token, context, partials, tags) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null) {\n      var lineHasNonSpace = token[6];\n      var tagIndex = token[5];\n      var indentation = token[4];\n      var indentedValue = value;\n      if (tagIndex == 0 && indentation) {\n        indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n      }\n      return this.renderTokens(this.parse(indentedValue, tags), context, partials, indentedValue, tags);\n    }\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return value;\n  };\n\n  Writer.prototype.escapedValue = function escapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue (token) {\n    return token[1];\n  };\n\n  var mustache = {\n    name: 'mustache.js',\n    version: '4.0.1',\n    tags: [ '{{', '}}' ],\n    clearCache: undefined,\n    escape: undefined,\n    parse: undefined,\n    render: undefined,\n    Scanner: undefined,\n    Context: undefined,\n    Writer: undefined,\n    /**\n     * Allows a user to override the default caching strategy, by providing an\n     * object with set, get and clear methods. This can also be used to disable\n     * the cache by setting it to the literal `undefined`.\n     */\n    set templateCache (cache) {\n      defaultWriter.templateCache = cache;\n    },\n    /**\n     * Gets the default or overridden caching object from the default writer.\n     */\n    get templateCache () {\n      return defaultWriter.templateCache;\n    }\n  };\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function clearCache () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function parse (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer. If the optional `tags` argument is given here it must be an\n   * array with two string values: the opening and closing tags used in the\n   * template (e.g. [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n   */\n  mustache.render = function render (template, view, partials, tags) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                          'but \"' + typeStr(template) + '\" was given as the first ' +\n                          'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials, tags);\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  return mustache;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUuanM/OWRiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLFNBQ3NEO0FBQ3hELENBQUMscUJBQXFCOztBQUV0QjtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsdUJBQXVCLG9CQUFvQixLQUFLO0FBQ2hELHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIscUJBQXFCOztBQUVyQjtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUJBQXFCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sd0NBQXdDO0FBQy9DO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsV0FBVyxVQUFVLFNBQVMsS0FBSyxvQkFBb0I7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL211c3RhY2hlL211c3RhY2hlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGhhcyBiZWVuIGdlbmVyYXRlZCBmcm9tIG11c3RhY2hlLm1qc1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5NdXN0YWNoZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKiFcbiAgICogbXVzdGFjaGUuanMgLSBMb2dpYy1sZXNzIHt7bXVzdGFjaGV9fSB0ZW1wbGF0ZXMgd2l0aCBKYXZhU2NyaXB0XG4gICAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAgICovXG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvKipcbiAgICogU2FmZSB3YXkgb2YgZGV0ZWN0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB0aGluZyBpcyBhIHByaW1pdGl2ZSBhbmRcbiAgICogd2hldGhlciBpdCBoYXMgdGhlIGdpdmVuIHByb3BlcnR5XG4gICAqL1xuICBmdW5jdGlvbiBwcmltaXRpdmVIYXNPd25Qcm9wZXJ0eSAocHJpbWl0aXZlLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBwcmltaXRpdmUgIT0gbnVsbFxuICAgICAgJiYgdHlwZW9mIHByaW1pdGl2ZSAhPT0gJ29iamVjdCdcbiAgICAgICYmIHByaW1pdGl2ZS5oYXNPd25Qcm9wZXJ0eVxuICAgICAgJiYgcHJpbWl0aXZlLmhhc093blByb3BlcnR5KHByb3BOYW1lKVxuICAgICk7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG4gIHZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnLyc6ICcmI3gyRjsnLFxuICAgICdgJzogJyYjeDYwOycsXG4gICAgJz0nOiAnJiN4M0Q7J1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2hpdGVSZSA9IC9cXHMqLztcbiAgdmFyIHNwYWNlUmUgPSAvXFxzKy87XG4gIHZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG4gIHZhciBjdXJseVJlID0gL1xccypcXH0vO1xuICB2YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuICAvKipcbiAgICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAgICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICAgKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAgICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICAgKlxuICAgKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gICAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gICAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAgICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gICAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAgICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gICAqXG4gICAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAgICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAgICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gICAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAgICpcbiAgICogVG9rZW5zIGZvciBwYXJ0aWFscyBhbHNvIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGEgc3RyaW5nIHZhbHVlIG9mXG4gICAqIGluZGVuZGF0aW9uIHByaW9yIHRvIHRoYXQgdGFnIGFuZCAyKSB0aGUgaW5kZXggb2YgdGhhdCB0YWcgb24gdGhhdCBsaW5lIC1cbiAgICogZWcgYSB2YWx1ZSBvZiAyIGluZGljYXRlcyB0aGUgcGFydGlhbCBpcyB0aGUgdGhpcmQgdGFnIG9uIHRoaXMgbGluZS5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgaWYgKCF0ZW1wbGF0ZSlcbiAgICAgIHJldHVybiBbXTtcbiAgICB2YXIgbGluZUhhc05vblNwYWNlID0gZmFsc2U7XG4gICAgdmFyIHNlY3Rpb25zID0gW107ICAgICAvLyBTdGFjayB0byBob2xkIHNlY3Rpb24gdG9rZW5zXG4gICAgdmFyIHRva2VucyA9IFtdOyAgICAgICAvLyBCdWZmZXIgdG8gaG9sZCB0aGUgdG9rZW5zXG4gICAgdmFyIHNwYWNlcyA9IFtdOyAgICAgICAvLyBJbmRpY2VzIG9mIHdoaXRlc3BhY2UgdG9rZW5zIG9uIHRoZSBjdXJyZW50IGxpbmVcbiAgICB2YXIgaGFzVGFnID0gZmFsc2U7ICAgIC8vIElzIHRoZXJlIGEge3t0YWd9fSBvbiB0aGUgY3VycmVudCBsaW5lP1xuICAgIHZhciBub25TcGFjZSA9IGZhbHNlOyAgLy8gSXMgdGhlcmUgYSBub24tc3BhY2UgY2hhciBvbiB0aGUgY3VycmVudCBsaW5lP1xuICAgIHZhciBpbmRlbnRhdGlvbiA9ICcnOyAgLy8gVHJhY2tzIGluZGVudGF0aW9uIGZvciB0YWdzIHRoYXQgdXNlIGl0XG4gICAgdmFyIHRhZ0luZGV4ID0gMDsgICAgICAvLyBTdG9yZXMgYSBjb3VudCBvZiBudW1iZXIgb2YgdGFncyBlbmNvdW50ZXJlZCBvbiBhIGxpbmVcblxuICAgIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gICAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFzVGFnID0gZmFsc2U7XG4gICAgICBub25TcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gICAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIH1cblxuICAgIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICAgIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICAgIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSBjaHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpbmVIYXNOb25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSAnICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2goWyAndGV4dCcsIGNociwgc3RhcnQsIHN0YXJ0ICsgMSBdKTtcbiAgICAgICAgICBzdGFydCArPSAxO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHdoaXRlc3BhY2Ugb24gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICBpZiAoY2hyID09PSAnXFxuJykge1xuICAgICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gPSAnJztcbiAgICAgICAgICAgIHRhZ0luZGV4ID0gMDtcbiAgICAgICAgICAgIGxpbmVIYXNOb25TcGFjZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgb3BlbmluZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihvcGVuaW5nVGFnUmUpKVxuICAgICAgICBicmVhaztcblxuICAgICAgaGFzVGFnID0gdHJ1ZTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdHlwZS5cbiAgICAgIHR5cGUgPSBzY2FubmVyLnNjYW4odGFnUmUpIHx8ICduYW1lJztcbiAgICAgIHNjYW5uZXIuc2Nhbih3aGl0ZVJlKTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdmFsdWUuXG4gICAgICBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW4oZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nQ3VybHlSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihjdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgICAgdHlwZSA9ICcmJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIGNsb3NpbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4oY2xvc2luZ1RhZ1JlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCB0YWcgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgICAgaWYgKHR5cGUgPT0gJz4nKSB7XG4gICAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zLCBpbmRlbnRhdGlvbiwgdGFnSW5kZXgsIGxpbmVIYXNOb25TcGFjZSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MgXTtcbiAgICAgIH1cbiAgICAgIHRhZ0luZGV4Kys7XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0eXBlID09PSAnIycgfHwgdHlwZSA9PT0gJ14nKSB7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnLycpIHtcbiAgICAgICAgLy8gQ2hlY2sgc2VjdGlvbiBuZXN0aW5nLlxuICAgICAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgICAgIGlmICghb3BlblNlY3Rpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbm9wZW5lZCBzZWN0aW9uIFwiJyArIHZhbHVlICsgJ1wiIGF0ICcgKyBzdGFydCk7XG5cbiAgICAgICAgaWYgKG9wZW5TZWN0aW9uWzFdICE9PSB2YWx1ZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWUnIHx8IHR5cGUgPT09ICd7JyB8fCB0eXBlID09PSAnJicpIHtcbiAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0YWdzIGZvciB0aGUgbmV4dCB0aW1lIGFyb3VuZC5cbiAgICAgICAgY29tcGlsZVRhZ3ModmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0cmlwU3BhY2UoKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gb3BlbiBzZWN0aW9ucyB3aGVuIHdlJ3JlIGRvbmUuXG4gICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgIGlmIChvcGVuU2VjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgcmV0dXJuIG5lc3RUb2tlbnMoc3F1YXNoVG9rZW5zKHRva2VucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVzIHRoZSB2YWx1ZXMgb2YgY29uc2VjdXRpdmUgdGV4dCB0b2tlbnMgaW4gdGhlIGdpdmVuIGB0b2tlbnNgIGFycmF5XG4gICAqIHRvIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cbiAgZnVuY3Rpb24gc3F1YXNoVG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgc3F1YXNoZWRUb2tlbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgbGFzdFRva2VuO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAndGV4dCcgJiYgbGFzdFRva2VuICYmIGxhc3RUb2tlblswXSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuWzFdICs9IHRva2VuWzFdO1xuICAgICAgICAgIGxhc3RUb2tlblszXSA9IHRva2VuWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNxdWFzaGVkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxdWFzaGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1zIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCBpbnRvIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlIHdoZXJlXG4gICAqIHRva2VucyB0aGF0IHJlcHJlc2VudCBhIHNlY3Rpb24gaGF2ZSB0d28gYWRkaXRpb25hbCBpdGVtczogMSkgYW4gYXJyYXkgb2ZcbiAgICogYWxsIHRva2VucyB0aGF0IGFwcGVhciBpbiB0aGF0IHNlY3Rpb24gYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWxcbiAgICogdGVtcGxhdGUgdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhhdCBzZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVzdFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIG5lc3RlZFRva2VucyA9IFtdO1xuICAgIHZhciBjb2xsZWN0b3IgPSBuZXN0ZWRUb2tlbnM7XG4gICAgdmFyIHNlY3Rpb25zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIHNlY3Rpb247XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgICAgc2VjdGlvbls1XSA9IHRva2VuWzJdO1xuICAgICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lc3RlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gICAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Nhbm5lciAoc3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50YWlsID0gc3RyaW5nO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFpbCBpcyBlbXB0eSAoZW5kIG9mIHN0cmluZykuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5lb3MgPSBmdW5jdGlvbiBlb3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWwgPT09ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiBzY2FuIChyZSkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMudGFpbC5tYXRjaChyZSk7XG5cbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgdmFyIHN0cmluZyA9IG1hdGNoWzBdO1xuXG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogU2tpcHMgYWxsIHRleHQgdW50aWwgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgbWF0Y2hlZC4gUmV0dXJuc1xuICAgKiB0aGUgc2tpcHBlZCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBlbnRpcmUgdGFpbCBpZiBubyBtYXRjaCBjYW4gYmUgbWFkZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW5VbnRpbCA9IGZ1bmN0aW9uIHNjYW5VbnRpbCAocmUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICBtYXRjaCA9IHRoaXMudGFpbDtcbiAgICAgICAgdGhpcy50YWlsID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICBtYXRjaCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1hdGNoID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIH1cblxuICAgIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gICAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICAgKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIGRvdCBub3RhdGlvbiBpcyB1c2VkLCB3ZSBjb25zaWRlciB0aGUgbG9va3VwXG4gICAgICAgICAgICogdG8gYmUgc3VjY2Vzc2Z1bCBldmVuIGlmIHRoZSBsYXN0IFwib2JqZWN0XCIgaW4gdGhlIHBhdGggaXNcbiAgICAgICAgICAgKiBub3QgYWN0dWFsbHkgYW4gb2JqZWN0IGJ1dCBhIHByaW1pdGl2ZSAoZS5nLiwgYSBzdHJpbmcsIG9yIGFuXG4gICAgICAgICAgICogaW50ZWdlciksIGJlY2F1c2UgaXQgaXMgc29tZXRpbWVzIHVzZWZ1bCB0byBhY2Nlc3MgYSBwcm9wZXJ0eVxuICAgICAgICAgICAqIG9mIGFuIGF1dG9ib3hlZCBwcmltaXRpdmUsIHN1Y2ggYXMgdGhlIGxlbmd0aCBvZiBhIHN0cmluZy5cbiAgICAgICAgICAgKiovXG4gICAgICAgICAgd2hpbGUgKGludGVybWVkaWF0ZVZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgbG9va3VwSGl0ID0gKFxuICAgICAgICAgICAgICAgIGhhc1Byb3BlcnR5KGludGVybWVkaWF0ZVZhbHVlLCBuYW1lc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgfHwgcHJpbWl0aXZlSGFzT3duUHJvcGVydHkoaW50ZXJtZWRpYXRlVmFsdWUsIG5hbWVzW2luZGV4XSlcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlVmFsdWUgPSBpbnRlcm1lZGlhdGVWYWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVybWVkaWF0ZVZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogT25seSBjaGVja2luZyBhZ2FpbnN0IGBoYXNQcm9wZXJ0eWAsIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAgaWZcbiAgICAgICAgICAgKiBgY29udGV4dC52aWV3YCBpcyBub3QgYW4gb2JqZWN0LiBEZWxpYmVyYXRlbHkgb21pdHRpbmcgdGhlIGNoZWNrXG4gICAgICAgICAgICogYWdhaW5zdCBgcHJpbWl0aXZlSGFzT3duUHJvcGVydHlgIGlmIGRvdCBub3RhdGlvbiBpcyBub3QgdXNlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIENvbnNpZGVyIHRoaXMgZXhhbXBsZTpcbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKiBNdXN0YWNoZS5yZW5kZXIoXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMge3sjbGVuZ3RofX17e2xlbmd0aH19e3svbGVuZ3RofX0uXCIsIHtsZW5ndGg6IFwiMTAwIHlhcmRzXCJ9KVxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogSWYgd2Ugd2VyZSB0byBjaGVjayBhbHNvIGFnYWluc3QgYHByaW1pdGl2ZUhhc093blByb3BlcnR5YCwgYXMgd2UgZG9cbiAgICAgICAgICAgKiBpbiB0aGUgZG90IG5vdGF0aW9uIGNhc2UsIHRoZW4gcmVuZGVyIGNhbGwgd291bGQgcmV0dXJuOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMgOS5cIlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogcmF0aGVyIHRoYW4gdGhlIGV4cGVjdGVkOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogXCJUaGUgbGVuZ3RoIG9mIGEgZm9vdGJhbGwgZmllbGQgaXMgMTAwIHlhcmRzLlwiXG4gICAgICAgICAgICoqL1xuICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va3VwSGl0KSB7XG4gICAgICAgICAgdmFsdWUgPSBpbnRlcm1lZGlhdGVWYWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gICAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICAgKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAgICovXG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gICAgdGhpcy50ZW1wbGF0ZUNhY2hlID0ge1xuICAgICAgX2NhY2hlOiB7fSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0IChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtrZXldO1xuICAgICAgfSxcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMudGVtcGxhdGVDYWNoZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgdGFnc2Agb3JcbiAgICogYG11c3RhY2hlLnRhZ3NgIGlmIGB0YWdzYCBpcyBvbWl0dGVkLCAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICAgKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLnRlbXBsYXRlQ2FjaGU7XG4gICAgdmFyIGNhY2hlS2V5ID0gdGVtcGxhdGUgKyAnOicgKyAodGFncyB8fCBtdXN0YWNoZS50YWdzKS5qb2luKCc6Jyk7XG4gICAgdmFyIGlzQ2FjaGVFbmFibGVkID0gdHlwZW9mIGNhY2hlICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgdG9rZW5zID0gaXNDYWNoZUVuYWJsZWQgPyBjYWNoZS5nZXQoY2FjaGVLZXkpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRva2VucyA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRva2VucyA9IHBhcnNlVGVtcGxhdGUodGVtcGxhdGUsIHRhZ3MpO1xuICAgICAgaXNDYWNoZUVuYWJsZWQgJiYgY2FjaGUuc2V0KGNhY2hlS2V5LCB0b2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAgICogdGhlIGdpdmVuIGB2aWV3YC5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAgICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAgICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gICAqXG4gICAqIElmIHRoZSBvcHRpb25hbCBgdGFnc2AgYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvXG4gICAqIHN0cmluZyB2YWx1ZXM6IHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy5cbiAgICogWyBcIjwlXCIsIFwiJT5cIiBdKS4gVGhlIGRlZmF1bHQgaXMgdG8gbXVzdGFjaGUudGFncy5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHRhZ3MpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gICAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIHRlbXBsYXRlLCB0YWdzKTtcbiAgfTtcblxuICAvKipcbiAgICogTG93LWxldmVsIG1ldGhvZCB0aGF0IHJlbmRlcnMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIHVzaW5nXG4gICAqIHRoZSBnaXZlbiBgY29udGV4dGAgYW5kIGBwYXJ0aWFsc2AuXG4gICAqXG4gICAqIE5vdGU6IFRoZSBgb3JpZ2luYWxUZW1wbGF0ZWAgaXMgb25seSBldmVyIHVzZWQgdG8gZXh0cmFjdCB0aGUgcG9ydGlvblxuICAgKiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB3YXMgY29udGFpbmVkIGluIGEgaGlnaGVyLW9yZGVyIHNlY3Rpb24uXG4gICAqIElmIHRoZSB0ZW1wbGF0ZSBkb2Vzbid0IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMsIHRoaXMgYXJndW1lbnQgbWF5XG4gICAqIGJlIG9taXR0ZWQuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclRva2VucyA9IGZ1bmN0aW9uIHJlbmRlclRva2VucyAodG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSwgdGFncykge1xuICAgIHZhciBidWZmZXIgPSAnJztcblxuICAgIHZhciB0b2tlbiwgc3ltYm9sLCB2YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgc3ltYm9sID0gdG9rZW5bMF07XG5cbiAgICAgIGlmIChzeW1ib2wgPT09ICcjJykgdmFsdWUgPSB0aGlzLnJlbmRlclNlY3Rpb24odG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ14nKSB2YWx1ZSA9IHRoaXMucmVuZGVySW52ZXJ0ZWQodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJz4nKSB2YWx1ZSA9IHRoaXMucmVuZGVyUGFydGlhbCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIHRhZ3MpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnJicpIHZhbHVlID0gdGhpcy51bmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICduYW1lJykgdmFsdWUgPSB0aGlzLmVzY2FwZWRWYWx1ZSh0b2tlbiwgY29udGV4dCk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICd0ZXh0JykgdmFsdWUgPSB0aGlzLnJhd1ZhbHVlKHRva2VuKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyU2VjdGlvbiA9IGZ1bmN0aW9uIHJlbmRlclNlY3Rpb24gKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYnVmZmVyID0gJyc7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlbmRlciBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAvLyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGJ5IGhpZ2hlci1vcmRlciBzZWN0aW9ucy5cbiAgICBmdW5jdGlvbiBzdWJSZW5kZXIgKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gc2VsZi5yZW5kZXIodGVtcGxhdGUsIGNvbnRleHQsIHBhcnRpYWxzKTtcbiAgICB9XG5cbiAgICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAodmFyIGogPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaiA8IHZhbHVlTGVuZ3RoOyArK2opIHtcbiAgICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWVbal0pLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LnB1c2godmFsdWUpLCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFRlbXBsYXRlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucyB3aXRob3V0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZScpO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHRoZSBzZWN0aW9uIGNvbnRhaW5zLlxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKGNvbnRleHQudmlldywgb3JpZ2luYWxUZW1wbGF0ZS5zbGljZSh0b2tlblszXSwgdG9rZW5bNV0pLCBzdWJSZW5kZXIpO1xuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlckludmVydGVkID0gZnVuY3Rpb24gcmVuZGVySW52ZXJ0ZWQgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFVzZSBKYXZhU2NyaXB0J3MgZGVmaW5pdGlvbiBvZiBmYWxzeS4gSW5jbHVkZSBlbXB0eSBhcnJheXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODZcbiAgICBpZiAoIXZhbHVlIHx8IChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5pbmRlbnRQYXJ0aWFsID0gZnVuY3Rpb24gaW5kZW50UGFydGlhbCAocGFydGlhbCwgaW5kZW50YXRpb24sIGxpbmVIYXNOb25TcGFjZSkge1xuICAgIHZhciBmaWx0ZXJlZEluZGVudGF0aW9uID0gaW5kZW50YXRpb24ucmVwbGFjZSgvW14gXFx0XS9nLCAnJyk7XG4gICAgdmFyIHBhcnRpYWxCeU5sID0gcGFydGlhbC5zcGxpdCgnXFxuJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWFsQnlObC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhcnRpYWxCeU5sW2ldLmxlbmd0aCAmJiAoaSA+IDAgfHwgIWxpbmVIYXNOb25TcGFjZSkpIHtcbiAgICAgICAgcGFydGlhbEJ5TmxbaV0gPSBmaWx0ZXJlZEluZGVudGF0aW9uICsgcGFydGlhbEJ5TmxbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWFsQnlObC5qb2luKCdcXG4nKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclBhcnRpYWwgPSBmdW5jdGlvbiByZW5kZXJQYXJ0aWFsICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIHRhZ3MpIHtcbiAgICBpZiAoIXBhcnRpYWxzKSByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIGxpbmVIYXNOb25TcGFjZSA9IHRva2VuWzZdO1xuICAgICAgdmFyIHRhZ0luZGV4ID0gdG9rZW5bNV07XG4gICAgICB2YXIgaW5kZW50YXRpb24gPSB0b2tlbls0XTtcbiAgICAgIHZhciBpbmRlbnRlZFZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGFnSW5kZXggPT0gMCAmJiBpbmRlbnRhdGlvbikge1xuICAgICAgICBpbmRlbnRlZFZhbHVlID0gdGhpcy5pbmRlbnRQYXJ0aWFsKHZhbHVlLCBpbmRlbnRhdGlvbiwgbGluZUhhc05vblNwYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0aGlzLnBhcnNlKGluZGVudGVkVmFsdWUsIHRhZ3MpLCBjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50ZWRWYWx1ZSwgdGFncyk7XG4gICAgfVxuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlblsxXTtcbiAgfTtcblxuICB2YXIgbXVzdGFjaGUgPSB7XG4gICAgbmFtZTogJ211c3RhY2hlLmpzJyxcbiAgICB2ZXJzaW9uOiAnNC4wLjEnLFxuICAgIHRhZ3M6IFsgJ3t7JywgJ319JyBdLFxuICAgIGNsZWFyQ2FjaGU6IHVuZGVmaW5lZCxcbiAgICBlc2NhcGU6IHVuZGVmaW5lZCxcbiAgICBwYXJzZTogdW5kZWZpbmVkLFxuICAgIHJlbmRlcjogdW5kZWZpbmVkLFxuICAgIFNjYW5uZXI6IHVuZGVmaW5lZCxcbiAgICBDb250ZXh0OiB1bmRlZmluZWQsXG4gICAgV3JpdGVyOiB1bmRlZmluZWQsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGEgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBjYWNoaW5nIHN0cmF0ZWd5LCBieSBwcm92aWRpbmcgYW5cbiAgICAgKiBvYmplY3Qgd2l0aCBzZXQsIGdldCBhbmQgY2xlYXIgbWV0aG9kcy4gVGhpcyBjYW4gYWxzbyBiZSB1c2VkIHRvIGRpc2FibGVcbiAgICAgKiB0aGUgY2FjaGUgYnkgc2V0dGluZyBpdCB0byB0aGUgbGl0ZXJhbCBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBzZXQgdGVtcGxhdGVDYWNoZSAoY2FjaGUpIHtcbiAgICAgIGRlZmF1bHRXcml0ZXIudGVtcGxhdGVDYWNoZSA9IGNhY2hlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCBvciBvdmVycmlkZGVuIGNhY2hpbmcgb2JqZWN0IGZyb20gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgICAqL1xuICAgIGdldCB0ZW1wbGF0ZUNhY2hlICgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnRlbXBsYXRlQ2FjaGU7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsbCBoaWdoLWxldmVsIG11c3RhY2hlLiogZnVuY3Rpb25zIHVzZSB0aGlzIHdyaXRlci5cbiAgdmFyIGRlZmF1bHRXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIuY2xlYXJDYWNoZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gdGVtcGxhdGUgaW4gdGhlIGRlZmF1bHQgd3JpdGVyIGFuZCByZXR1cm5zIHRoZVxuICAgKiBhcnJheSBvZiB0b2tlbnMgaXQgY29udGFpbnMuIERvaW5nIHRoaXMgYWhlYWQgb2YgdGltZSBhdm9pZHMgdGhlIG5lZWQgdG9cbiAgICogcGFyc2UgdGVtcGxhdGVzIG9uIHRoZSBmbHkgYXMgdGhleSBhcmUgcmVuZGVyZWQuXG4gICAqL1xuICBtdXN0YWNoZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnBhcnNlKHRlbXBsYXRlLCB0YWdzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYHRlbXBsYXRlYCB3aXRoIHRoZSBnaXZlbiBgdmlld2AgYW5kIGBwYXJ0aWFsc2AgdXNpbmcgdGhlXG4gICAqIGRlZmF1bHQgd3JpdGVyLiBJZiB0aGUgb3B0aW9uYWwgYHRhZ3NgIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUgaXQgbXVzdCBiZSBhblxuICAgKiBhcnJheSB3aXRoIHR3byBzdHJpbmcgdmFsdWVzOiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlXG4gICAqIHRlbXBsYXRlIChlLmcuIFsgXCI8JVwiLCBcIiU+XCIgXSkuIFRoZSBkZWZhdWx0IGlzIHRvIG11c3RhY2hlLnRhZ3MuXG4gICAqL1xuICBtdXN0YWNoZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgdGFncykge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRlbXBsYXRlISBUZW1wbGF0ZSBzaG91bGQgYmUgYSBcInN0cmluZ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYnV0IFwiJyArIHR5cGVTdHIodGVtcGxhdGUpICsgJ1wiIHdhcyBnaXZlbiBhcyB0aGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudCBmb3IgbXVzdGFjaGUjcmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCB0YWdzKTtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxuICBtdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4gIC8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbiAgbXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG4gIG11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xuICBtdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbiAgcmV0dXJuIG11c3RhY2hlO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mustache/mustache.js\n");

/***/ }),

/***/ "./node_modules/swork-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/swork-router/dist/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_to_regexp_1 = __webpack_require__(/*! path-to-regexp */ \"./node_modules/swork-router/node_modules/path-to-regexp/dist.es2015/index.js\");\r\nconst configuration_1 = __webpack_require__(/*! swork/dist/configuration */ \"./node_modules/swork/dist/configuration.js\");\r\n/**\r\n * Router intended to be used with swork. Allows definition of paths and middleware to handle matching requests.\r\n *\r\n * @export\r\n * @class Router\r\n */\r\nclass Router {\r\n    /**\r\n     * Creates an instance of Router.\r\n     * @param {IRouterConfiguration} [config]\r\n     * @memberof Router\r\n     */\r\n    constructor(config) {\r\n        this.middlewareDetails = [];\r\n        this.routesCalled = false;\r\n        this.config = Object.assign({\r\n            origin: configuration_1.configuration.origin,\r\n            prefix: \"\",\r\n        }, config);\r\n        if (this.config.prefix) {\r\n            this.validatePaths([this.config.prefix]);\r\n        }\r\n    }\r\n    /**\r\n     * Defines a head request handler.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    head(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"HEAD\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Defines an options request handler.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    options(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"OPTIONS\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Defines a get request handler.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    get(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"GET\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Defines a post request handler.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    post(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"POST\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Defines a patch request handler.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    patch(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"PATCH\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Defines a put request handler.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    put(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"PUT\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Defines a delete request handler.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    delete(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"DELETE\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Defines a request handler for all HTTP verbs.\r\n     *\r\n     * @param {string} path\r\n     * @param {Middleware} middleware\r\n     * @returns {Router}\r\n     * @memberof Router\r\n     */\r\n    all(path, middleware) {\r\n        this.addMiddlewareDetails(path, [\"HEAD\", \"OPTIONS\", \"GET\", \"PUT\", \"PATCH\", \"POST\", \"DELETE\"], middleware);\r\n        return this;\r\n    }\r\n    /**\r\n     * Builds the middlewares from the router to be used by swork.\r\n     *\r\n     * @returns {Middleware[]}\r\n     * @memberof Router\r\n     */\r\n    routes() {\r\n        if (this.routesCalled) {\r\n            throw new Error(\"Routes can only be called once.\");\r\n        }\r\n        if (!this.config.origin) {\r\n            throw new Error(\"Origin must be non-empty.\");\r\n        }\r\n        const middleware = [];\r\n        this.middlewareDetails.forEach((detail) => {\r\n            if (detail instanceof Router) {\r\n                if (this.config.prefix) {\r\n                    detail.config.prefix = this.config.prefix + detail.config.prefix;\r\n                }\r\n                detail.config.origin = this.config.origin;\r\n                Array.prototype.push.apply(middleware, detail.routes());\r\n            }\r\n            else {\r\n                Array.prototype.push.apply(middleware, this.build(detail.path, detail.methods, detail.middleware));\r\n            }\r\n        });\r\n        this.routesCalled = true;\r\n        return middleware;\r\n    }\r\n    /**\r\n     * Adds to the internal middlewares allowing nested routers.\r\n     *\r\n     * @param {(Router)} param\r\n     * @memberof Router\r\n     */\r\n    use(param) {\r\n        this.middlewareDetails.push(param);\r\n    }\r\n    addMiddlewareDetails(path, methods, middleware) {\r\n        if (!Array.isArray(path)) {\r\n            path = [path];\r\n        }\r\n        this.validatePaths(path);\r\n        this.middlewareDetails.push({\r\n            methods,\r\n            middleware,\r\n            path,\r\n        });\r\n    }\r\n    build(paths, methods, middleware) {\r\n        const results = [];\r\n        paths.forEach((path) => {\r\n            if (this.config.prefix) {\r\n                path = this.config.prefix + path;\r\n            }\r\n            const paramNames = [];\r\n            const regexp = path_to_regexp_1.pathToRegexp(path, paramNames);\r\n            const origin = this.config.origin;\r\n            results.push((context, next) => {\r\n                if (methods.indexOf(context.request.method) === -1) {\r\n                    return next();\r\n                }\r\n                const url = new URL(context.request.url);\r\n                if (origin !== url.origin.toLowerCase()) {\r\n                    return next();\r\n                }\r\n                if (!regexp.test(url.pathname)) {\r\n                    return next();\r\n                }\r\n                context.params = {};\r\n                if (paramNames.length) {\r\n                    const params = url.pathname.match(regexp).slice(1);\r\n                    params.forEach((value, index) => {\r\n                        context.params[paramNames[index].name] = value;\r\n                    });\r\n                }\r\n                return Promise.resolve(middleware(context, next));\r\n            });\r\n        });\r\n        return results;\r\n    }\r\n    validatePaths(paths) {\r\n        const invalidPaths = [];\r\n        paths.forEach((path) => {\r\n            if (path[0] !== \"/\") {\r\n                invalidPaths.push(path);\r\n            }\r\n            else if (path.length > 1 && path[path.length - 1] === \"/\") {\r\n                invalidPaths.push(path);\r\n            }\r\n        });\r\n        if (invalidPaths.length) {\r\n            throw new Error(`Path(s) [\"${invalidPaths.join(\"\\\", \\\"\")}\"] do not have a valid format.`);\r\n        }\r\n    }\r\n}\r\nexports.Router = Router;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dvcmstcm91dGVyL2Rpc3QvaW5kZXguanM/ZmQ3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELHlCQUF5QixtQkFBTyxDQUFDLG9HQUFnQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyw0RUFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zd29yay1yb3V0ZXIvZGlzdC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHBhdGhfdG9fcmVnZXhwXzEgPSByZXF1aXJlKFwicGF0aC10by1yZWdleHBcIik7XHJcbmNvbnN0IGNvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCJzd29yay9kaXN0L2NvbmZpZ3VyYXRpb25cIik7XHJcbi8qKlxyXG4gKiBSb3V0ZXIgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIHN3b3JrLiBBbGxvd3MgZGVmaW5pdGlvbiBvZiBwYXRocyBhbmQgbWlkZGxld2FyZSB0byBoYW5kbGUgbWF0Y2hpbmcgcmVxdWVzdHMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIFJvdXRlclxyXG4gKi9cclxuY2xhc3MgUm91dGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSb3V0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0lSb3V0ZXJDb25maWd1cmF0aW9ufSBbY29uZmlnXVxyXG4gICAgICogQG1lbWJlcm9mIFJvdXRlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICB0aGlzLm1pZGRsZXdhcmVEZXRhaWxzID0gW107XHJcbiAgICAgICAgdGhpcy5yb3V0ZXNDYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgICAgICBvcmlnaW46IGNvbmZpZ3VyYXRpb25fMS5jb25maWd1cmF0aW9uLm9yaWdpbixcclxuICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxyXG4gICAgICAgIH0sIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByZWZpeCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGF0aHMoW3RoaXMuY29uZmlnLnByZWZpeF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIGhlYWQgcmVxdWVzdCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge01pZGRsZXdhcmV9IG1pZGRsZXdhcmVcclxuICAgICAqIEByZXR1cm5zIHtSb3V0ZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUm91dGVyXHJcbiAgICAgKi9cclxuICAgIGhlYWQocGF0aCwgbWlkZGxld2FyZSkge1xyXG4gICAgICAgIHRoaXMuYWRkTWlkZGxld2FyZURldGFpbHMocGF0aCwgW1wiSEVBRFwiXSwgbWlkZGxld2FyZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYW4gb3B0aW9ucyByZXF1ZXN0IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7TWlkZGxld2FyZX0gbWlkZGxld2FyZVxyXG4gICAgICogQHJldHVybnMge1JvdXRlcn1cclxuICAgICAqIEBtZW1iZXJvZiBSb3V0ZXJcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucyhwYXRoLCBtaWRkbGV3YXJlKSB7XHJcbiAgICAgICAgdGhpcy5hZGRNaWRkbGV3YXJlRGV0YWlscyhwYXRoLCBbXCJPUFRJT05TXCJdLCBtaWRkbGV3YXJlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIGdldCByZXF1ZXN0IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7TWlkZGxld2FyZX0gbWlkZGxld2FyZVxyXG4gICAgICogQHJldHVybnMge1JvdXRlcn1cclxuICAgICAqIEBtZW1iZXJvZiBSb3V0ZXJcclxuICAgICAqL1xyXG4gICAgZ2V0KHBhdGgsIG1pZGRsZXdhcmUpIHtcclxuICAgICAgICB0aGlzLmFkZE1pZGRsZXdhcmVEZXRhaWxzKHBhdGgsIFtcIkdFVFwiXSwgbWlkZGxld2FyZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBwb3N0IHJlcXVlc3QgaGFuZGxlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxyXG4gICAgICogQHBhcmFtIHtNaWRkbGV3YXJlfSBtaWRkbGV3YXJlXHJcbiAgICAgKiBAcmV0dXJucyB7Um91dGVyfVxyXG4gICAgICogQG1lbWJlcm9mIFJvdXRlclxyXG4gICAgICovXHJcbiAgICBwb3N0KHBhdGgsIG1pZGRsZXdhcmUpIHtcclxuICAgICAgICB0aGlzLmFkZE1pZGRsZXdhcmVEZXRhaWxzKHBhdGgsIFtcIlBPU1RcIl0sIG1pZGRsZXdhcmUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGEgcGF0Y2ggcmVxdWVzdCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge01pZGRsZXdhcmV9IG1pZGRsZXdhcmVcclxuICAgICAqIEByZXR1cm5zIHtSb3V0ZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUm91dGVyXHJcbiAgICAgKi9cclxuICAgIHBhdGNoKHBhdGgsIG1pZGRsZXdhcmUpIHtcclxuICAgICAgICB0aGlzLmFkZE1pZGRsZXdhcmVEZXRhaWxzKHBhdGgsIFtcIlBBVENIXCJdLCBtaWRkbGV3YXJlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lcyBhIHB1dCByZXF1ZXN0IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcclxuICAgICAqIEBwYXJhbSB7TWlkZGxld2FyZX0gbWlkZGxld2FyZVxyXG4gICAgICogQHJldHVybnMge1JvdXRlcn1cclxuICAgICAqIEBtZW1iZXJvZiBSb3V0ZXJcclxuICAgICAqL1xyXG4gICAgcHV0KHBhdGgsIG1pZGRsZXdhcmUpIHtcclxuICAgICAgICB0aGlzLmFkZE1pZGRsZXdhcmVEZXRhaWxzKHBhdGgsIFtcIlBVVFwiXSwgbWlkZGxld2FyZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgYSBkZWxldGUgcmVxdWVzdCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge01pZGRsZXdhcmV9IG1pZGRsZXdhcmVcclxuICAgICAqIEByZXR1cm5zIHtSb3V0ZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUm91dGVyXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZShwYXRoLCBtaWRkbGV3YXJlKSB7XHJcbiAgICAgICAgdGhpcy5hZGRNaWRkbGV3YXJlRGV0YWlscyhwYXRoLCBbXCJERUxFVEVcIl0sIG1pZGRsZXdhcmUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIGEgcmVxdWVzdCBoYW5kbGVyIGZvciBhbGwgSFRUUCB2ZXJicy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxyXG4gICAgICogQHBhcmFtIHtNaWRkbGV3YXJlfSBtaWRkbGV3YXJlXHJcbiAgICAgKiBAcmV0dXJucyB7Um91dGVyfVxyXG4gICAgICogQG1lbWJlcm9mIFJvdXRlclxyXG4gICAgICovXHJcbiAgICBhbGwocGF0aCwgbWlkZGxld2FyZSkge1xyXG4gICAgICAgIHRoaXMuYWRkTWlkZGxld2FyZURldGFpbHMocGF0aCwgW1wiSEVBRFwiLCBcIk9QVElPTlNcIiwgXCJHRVRcIiwgXCJQVVRcIiwgXCJQQVRDSFwiLCBcIlBPU1RcIiwgXCJERUxFVEVcIl0sIG1pZGRsZXdhcmUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZHMgdGhlIG1pZGRsZXdhcmVzIGZyb20gdGhlIHJvdXRlciB0byBiZSB1c2VkIGJ5IHN3b3JrLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtNaWRkbGV3YXJlW119XHJcbiAgICAgKiBAbWVtYmVyb2YgUm91dGVyXHJcbiAgICAgKi9cclxuICAgIHJvdXRlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5yb3V0ZXNDYWxsZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm91dGVzIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5vcmlnaW4pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3JpZ2luIG11c3QgYmUgbm9uLWVtcHR5LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWlkZGxld2FyZURldGFpbHMuZm9yRWFjaCgoZGV0YWlsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkZXRhaWwgaW5zdGFuY2VvZiBSb3V0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5wcmVmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXRhaWwuY29uZmlnLnByZWZpeCA9IHRoaXMuY29uZmlnLnByZWZpeCArIGRldGFpbC5jb25maWcucHJlZml4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGV0YWlsLmNvbmZpZy5vcmlnaW4gPSB0aGlzLmNvbmZpZy5vcmlnaW47XHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShtaWRkbGV3YXJlLCBkZXRhaWwucm91dGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobWlkZGxld2FyZSwgdGhpcy5idWlsZChkZXRhaWwucGF0aCwgZGV0YWlsLm1ldGhvZHMsIGRldGFpbC5taWRkbGV3YXJlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJvdXRlc0NhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdG8gdGhlIGludGVybmFsIG1pZGRsZXdhcmVzIGFsbG93aW5nIG5lc3RlZCByb3V0ZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KFJvdXRlcil9IHBhcmFtXHJcbiAgICAgKiBAbWVtYmVyb2YgUm91dGVyXHJcbiAgICAgKi9cclxuICAgIHVzZShwYXJhbSkge1xyXG4gICAgICAgIHRoaXMubWlkZGxld2FyZURldGFpbHMucHVzaChwYXJhbSk7XHJcbiAgICB9XHJcbiAgICBhZGRNaWRkbGV3YXJlRGV0YWlscyhwYXRoLCBtZXRob2RzLCBtaWRkbGV3YXJlKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXRocyhwYXRoKTtcclxuICAgICAgICB0aGlzLm1pZGRsZXdhcmVEZXRhaWxzLnB1c2goe1xyXG4gICAgICAgICAgICBtZXRob2RzLFxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlLFxyXG4gICAgICAgICAgICBwYXRoLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYnVpbGQocGF0aHMsIG1ldGhvZHMsIG1pZGRsZXdhcmUpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcucHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5jb25maWcucHJlZml4ICsgcGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwYXJhbU5hbWVzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4cCA9IHBhdGhfdG9fcmVnZXhwXzEucGF0aFRvUmVnZXhwKHBhdGgsIHBhcmFtTmFtZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmNvbmZpZy5vcmlnaW47XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCgoY29udGV4dCwgbmV4dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZHMuaW5kZXhPZihjb250ZXh0LnJlcXVlc3QubWV0aG9kKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChjb250ZXh0LnJlcXVlc3QudXJsKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4gIT09IHVybC5vcmlnaW4udG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4cC50ZXN0KHVybC5wYXRobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wYXJhbXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJhbU5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHVybC5wYXRobmFtZS5tYXRjaChyZWdleHApLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXJhbXNbcGFyYW1OYW1lc1tpbmRleF0ubmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWlkZGxld2FyZShjb250ZXh0LCBuZXh0KSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRocyhwYXRocykge1xyXG4gICAgICAgIGNvbnN0IGludmFsaWRQYXRocyA9IFtdO1xyXG4gICAgICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBhdGhbMF0gIT09IFwiL1wiKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXRoLmxlbmd0aCA+IDEgJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xyXG4gICAgICAgICAgICAgICAgaW52YWxpZFBhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaW52YWxpZFBhdGhzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGgocykgW1wiJHtpbnZhbGlkUGF0aHMuam9pbihcIlxcXCIsIFxcXCJcIil9XCJdIGRvIG5vdCBoYXZlIGEgdmFsaWQgZm9ybWF0LmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJvdXRlciA9IFJvdXRlcjtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/swork-router/dist/index.js\n");

/***/ }),

/***/ "./node_modules/swork-router/node_modules/path-to-regexp/dist.es2015/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/swork-router/node_modules/path-to-regexp/dist.es2015/index.js ***!
  \************************************************************************************/
/*! exports provided: parse, compile, tokensToFunction, match, regexpToFunction, tokensToRegexp, pathToRegexp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compile\", function() { return compile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokensToFunction\", function() { return tokensToFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"match\", function() { return match; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regexpToFunction\", function() { return regexpToFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tokensToRegexp\", function() { return tokensToRegexp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pathToRegexp\", function() { return pathToRegexp; });\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = \"/\";\n/**\n * Balanced bracket helper function.\n */\nfunction balanced(open, close, str, index) {\n    var count = 0;\n    var i = index;\n    while (i < str.length) {\n        if (str[i] === \"\\\\\") {\n            i += 2;\n            continue;\n        }\n        if (str[i] === close) {\n            count--;\n            if (count === 0)\n                return i + 1;\n        }\n        if (str[i] === open) {\n            count++;\n        }\n        i++;\n    }\n    return -1;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var _a, _b;\n    var tokens = [];\n    var defaultDelimiter = (_a = options.delimiter, (_a !== null && _a !== void 0 ? _a : DEFAULT_DELIMITER));\n    var whitelist = (_b = options.whitelist, (_b !== null && _b !== void 0 ? _b : undefined));\n    var i = 0;\n    var key = 0;\n    var path = \"\";\n    var isEscaped = false;\n    // tslint:disable-next-line\n    while (i < str.length) {\n        var prefix = \"\";\n        var name = \"\";\n        var pattern = \"\";\n        // Ignore escaped sequences.\n        if (str[i] === \"\\\\\") {\n            i++;\n            path += str[i++];\n            isEscaped = true;\n            continue;\n        }\n        if (str[i] === \":\") {\n            while (++i < str.length) {\n                var code = str.charCodeAt(i);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[i];\n                    continue;\n                }\n                break;\n            }\n            // False positive on param name.\n            if (!name)\n                i--;\n        }\n        if (str[i] === \"(\") {\n            var end = balanced(\"(\", \")\", str, i);\n            // False positive on matching brackets.\n            if (end > -1) {\n                pattern = str.slice(i + 1, end - 1);\n                i = end;\n                if (pattern[0] === \"?\") {\n                    throw new TypeError(\"Path pattern must be a capturing group\");\n                }\n                if (/\\((?=[^?])/.test(pattern)) {\n                    var validPattern = pattern.replace(/\\((?=[^?])/, \"(?:\");\n                    throw new TypeError(\"Capturing groups are not allowed in pattern, use a non-capturing group: (\" + validPattern + \")\");\n                }\n            }\n        }\n        // Add regular characters to the path string.\n        if (name === \"\" && pattern === \"\") {\n            path += str[i++];\n            isEscaped = false;\n            continue;\n        }\n        // Extract the final character from `path` for the prefix.\n        if (path.length && !isEscaped) {\n            var char = path[path.length - 1];\n            var matches = whitelist ? whitelist.indexOf(char) > -1 : true;\n            if (matches) {\n                prefix = char;\n                path = path.slice(0, -1);\n            }\n        }\n        // Push the current path onto the list of tokens.\n        if (path.length) {\n            tokens.push(path);\n            path = \"\";\n        }\n        var repeat = str[i] === \"+\" || str[i] === \"*\";\n        var optional = str[i] === \"?\" || str[i] === \"*\";\n        var delimiter = prefix || defaultDelimiter;\n        // Increment `i` past modifier token.\n        if (repeat || optional)\n            i++;\n        tokens.push({\n            name: name || key++,\n            prefix: prefix,\n            delimiter: delimiter,\n            optional: optional,\n            repeat: repeat,\n            pattern: pattern ||\n                \"[^\" + escapeString(delimiter === defaultDelimiter\n                    ? delimiter\n                    : delimiter + defaultDelimiter) + \"]+?\"\n        });\n    }\n    if (path.length)\n        tokens.push(path);\n    return tokens;\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            if (Array.isArray(value)) {\n                if (!token.repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (token.optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += (j === 0 ? token.prefix : token.delimiter) + segment;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment;\n                continue;\n            }\n            if (token.optional)\n                continue;\n            var typeOfMessage = token.repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.repeat) {\n                params[key.name] = m[i].split(key.delimiter).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                delimiter: \"\",\n                optional: false,\n                repeat: false,\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var strict = options.strict, _a = options.start, start = _a === void 0 ? true : _a, _b = options.end, end = _b === void 0 ? true : _b, _c = options.delimiter, delimiter = _c === void 0 ? DEFAULT_DELIMITER : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = (typeof options.endsWith === \"string\"\n        ? options.endsWith.split(\"\")\n        : options.endsWith || [])\n        .map(escapeString)\n        .concat(\"$\")\n        .join(\"|\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var capture = token.repeat\n                ? \"(?:\" + token.pattern + \")(?:\" + escapeString(token.delimiter) + \"(?:\" + token.pattern + \"))*\"\n                : token.pattern;\n            if (keys)\n                keys.push(token);\n            if (token.optional) {\n                if (!token.prefix) {\n                    route += \"(\" + capture + \")?\";\n                }\n                else {\n                    route += \"(?:\" + escapeString(token.prefix) + \"(\" + capture + \"))?\";\n                }\n            }\n            else {\n                route += escapeString(token.prefix) + \"(\" + capture + \")\";\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"(?:\" + escapeString(delimiter) + \")?\";\n        route += endsWith === \"$\" ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? endToken[endToken.length - 1] === delimiter\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + escapeString(delimiter) + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + escapeString(delimiter) + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp) {\n        return regexpToRegexp(path, keys);\n    }\n    if (Array.isArray(path)) {\n        return arrayToRegexp(path, keys, options);\n    }\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dvcmstcm91dGVyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9kaXN0LmVzMjAxNS9pbmRleC5qcz8wMWM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQSxvRUFBb0UsVUFBVSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsY0FBYztBQUMzQyxvRUFBb0UsVUFBVSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixjQUFjO0FBQzNDLG1SQUFtUixVQUFVLEVBQUU7QUFDL1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBNkQ7QUFDM0U7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zd29yay1yb3V0ZXIvbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2Rpc3QuZXMyMDE1L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZWZhdWx0IGNvbmZpZ3MuXG4gKi9cbnZhciBERUZBVUxUX0RFTElNSVRFUiA9IFwiL1wiO1xuLyoqXG4gKiBCYWxhbmNlZCBicmFja2V0IGhlbHBlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFsYW5jZWQob3BlbiwgY2xvc2UsIHN0ciwgaW5kZXgpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBpID0gaW5kZXg7XG4gICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW2ldID09PSBjbG9zZSkge1xuICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltpXSA9PT0gb3Blbikge1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgZGVmYXVsdERlbGltaXRlciA9IChfYSA9IG9wdGlvbnMuZGVsaW1pdGVyLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9ERUxJTUlURVIpKTtcbiAgICB2YXIgd2hpdGVsaXN0ID0gKF9iID0gb3B0aW9ucy53aGl0ZWxpc3QsIChfYiAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQpKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSA9IDA7XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHZhciBpc0VzY2FwZWQgPSBmYWxzZTtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IFwiXCI7XG4gICAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAvLyBJZ25vcmUgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgICAgIGlmIChzdHJbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBwYXRoICs9IHN0cltpKytdO1xuICAgICAgICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbaV0gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltpXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsc2UgcG9zaXRpdmUgb24gcGFyYW0gbmFtZS5cbiAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltpXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSBiYWxhbmNlZChcIihcIiwgXCIpXCIsIHN0ciwgaSk7XG4gICAgICAgICAgICAvLyBGYWxzZSBwb3NpdGl2ZSBvbiBtYXRjaGluZyBicmFja2V0cy5cbiAgICAgICAgICAgIGlmIChlbmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBzdHIuc2xpY2UoaSArIDEsIGVuZCAtIDEpO1xuICAgICAgICAgICAgICAgIGkgPSBlbmQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5bMF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXRoIHBhdHRlcm4gbXVzdCBiZSBhIGNhcHR1cmluZyBncm91cFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9cXCgoPz1bXj9dKS8udGVzdChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRQYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC9cXCgoPz1bXj9dKS8sIFwiKD86XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgaW4gcGF0dGVybiwgdXNlIGEgbm9uLWNhcHR1cmluZyBncm91cDogKFwiICsgdmFsaWRQYXR0ZXJuICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgcmVndWxhciBjaGFyYWN0ZXJzIHRvIHRoZSBwYXRoIHN0cmluZy5cbiAgICAgICAgaWYgKG5hbWUgPT09IFwiXCIgJiYgcGF0dGVybiA9PT0gXCJcIikge1xuICAgICAgICAgICAgcGF0aCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGlzRXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgZmluYWwgY2hhcmFjdGVyIGZyb20gYHBhdGhgIGZvciB0aGUgcHJlZml4LlxuICAgICAgICBpZiAocGF0aC5sZW5ndGggJiYgIWlzRXNjYXBlZCkge1xuICAgICAgICAgICAgdmFyIGNoYXIgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHdoaXRlbGlzdCA/IHdoaXRlbGlzdC5pbmRleE9mKGNoYXIpID4gLTEgOiB0cnVlO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBjaGFyO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgbGlzdCBvZiB0b2tlbnMuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwZWF0ID0gc3RyW2ldID09PSBcIitcIiB8fCBzdHJbaV0gPT09IFwiKlwiO1xuICAgICAgICB2YXIgb3B0aW9uYWwgPSBzdHJbaV0gPT09IFwiP1wiIHx8IHN0cltpXSA9PT0gXCIqXCI7XG4gICAgICAgIHZhciBkZWxpbWl0ZXIgPSBwcmVmaXggfHwgZGVmYXVsdERlbGltaXRlcjtcbiAgICAgICAgLy8gSW5jcmVtZW50IGBpYCBwYXN0IG1vZGlmaWVyIHRva2VuLlxuICAgICAgICBpZiAocmVwZWF0IHx8IG9wdGlvbmFsKVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgICAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgICAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgICAgICAgcGF0dGVybjogcGF0dGVybiB8fFxuICAgICAgICAgICAgICAgIFwiW15cIiArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIgPT09IGRlZmF1bHREZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAgICAgPyBkZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICAgICAgOiBkZWxpbWl0ZXIgKyBkZWZhdWx0RGVsaW1pdGVyKSArIFwiXSs/XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXRoLmxlbmd0aClcbiAgICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGUoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZUZsYWdzID0gZmxhZ3Mob3B0aW9ucyk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hLCBfYiA9IG9wdGlvbnMudmFsaWRhdGUsIHZhbGlkYXRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgICB2YXIgbWF0Y2hlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSRcIiwgcmVGbGFncyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhID8gZGF0YVt0b2tlbi5uYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFsbCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiICsgdG9rZW4ucGF0dGVybiArIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdHlwZU9mTWVzc2FnZSA9IHRva2VuLnJlcGVhdCA/IFwiYW4gYXJyYXlcIiA6IFwiYSBzdHJpbmdcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIGJlIFwiICsgdHlwZU9mTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIHNwZWMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaChzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciByZSA9IHBhdGhUb1JlZ2V4cChzdHIsIGtleXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgb3V0cHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5kZWNvZGUsIGRlY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGF0aCA9IG1bMF0sIGluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gbVtpXS5zcGxpdChrZXkuZGVsaW1pdGVyKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBpLFxuICAgICAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwKHBhdGhzLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnRzID0gcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykuc291cmNlOyB9KTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlwiICsgcGFydHMuam9pbihcInxcIikgKyBcIilcIiwgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb1JlZ2V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCwgX2EgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIF9iID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5kZWxpbWl0ZXIsIGRlbGltaXRlciA9IF9jID09PSB2b2lkIDAgPyBERUZBVUxUX0RFTElNSVRFUiA6IF9jLCBfZCA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfZCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfZDtcbiAgICB2YXIgZW5kc1dpdGggPSAodHlwZW9mIG9wdGlvbnMuZW5kc1dpdGggPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBvcHRpb25zLmVuZHNXaXRoLnNwbGl0KFwiXCIpXG4gICAgICAgIDogb3B0aW9ucy5lbmRzV2l0aCB8fCBbXSlcbiAgICAgICAgLm1hcChlc2NhcGVTdHJpbmcpXG4gICAgICAgIC5jb25jYXQoXCIkXCIpXG4gICAgICAgIC5qb2luKFwifFwiKTtcbiAgICB2YXIgcm91dGUgPSBzdGFydCA/IFwiXlwiIDogXCJcIjtcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICAgIGZvciAodmFyIF9pID0gMCwgdG9rZW5zXzEgPSB0b2tlbnM7IF9pIDwgdG9rZW5zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc18xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSB0b2tlbi5yZXBlYXRcbiAgICAgICAgICAgICAgICA/IFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKD86XCIgKyBlc2NhcGVTdHJpbmcodG9rZW4uZGVsaW1pdGVyKSArIFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKSpcIlxuICAgICAgICAgICAgICAgIDogdG9rZW4ucGF0dGVybjtcbiAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICAgIGtleXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuLnByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIihcIiArIGNhcHR1cmUgKyBcIik/XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeCkgKyBcIihcIiArIGNhcHR1cmUgKyBcIikpP1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpICsgXCIoXCIgKyBjYXB0dXJlICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIXN0cmljdClcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArIFwiKT9cIjtcbiAgICAgICAgcm91dGUgKz0gZW5kc1dpdGggPT09IFwiJFwiID8gXCIkXCIgOiBcIig/PVwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlbmRUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc0VuZERlbGltaXRlZCA9IHR5cGVvZiBlbmRUb2tlbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBlbmRUb2tlbltlbmRUb2tlbi5sZW5ndGggLSAxXSA9PT0gZGVsaW1pdGVyXG4gICAgICAgICAgICA6IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgICAgIGVuZFRva2VuID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyBcIig/PVwiICsgZW5kc1dpdGggKyBcIikpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArIFwifFwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyb3V0ZSwgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cyk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/swork-router/node_modules/path-to-regexp/dist.es2015/index.js\n");

/***/ }),

/***/ "./node_modules/swork/dist/builder.js":
/*!********************************************!*\
  !*** ./node_modules/swork/dist/builder.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fetch_context_1 = __webpack_require__(/*! ./fetch-context */ \"./node_modules/swork/dist/fetch-context.js\");\r\nfunction addExtendableEvent(eventType, handlers) {\r\n    if (handlers.length) {\r\n        self.addEventListener(eventType, exports.eventListeners.extendableEvent(handlers));\r\n    }\r\n}\r\nfunction addFetchEvent(delegate) {\r\n    self.addEventListener(\"fetch\", exports.eventListeners.fetchEvent(delegate));\r\n}\r\nfunction getExtendableEventListener(handlers) {\r\n    const handler = exports.eventHandlers.extendableEvent(handlers);\r\n    return (event) => __awaiter(this, void 0, void 0, function* () {\r\n        event.waitUntil(handler(event));\r\n    });\r\n}\r\nfunction getFetchEventListener(delegate) {\r\n    return (event) => {\r\n        const fetchEvent = event;\r\n        const handler = exports.eventHandlers.fetchEvent(delegate, fetchEvent);\r\n        fetchEvent.waitUntil(handler);\r\n        fetchEvent.respondWith(handler);\r\n    };\r\n}\r\nfunction getExtendableEventHandler(handlers) {\r\n    return (event) => __awaiter(this, void 0, void 0, function* () {\r\n        yield Promise.all(handlers.map((handler) => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield handler(event);\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n            }\r\n        })));\r\n    });\r\n}\r\nfunction getFetchEventHandler(delegate, fetchEvent) {\r\n    return (() => __awaiter(this, void 0, void 0, function* () {\r\n        const fetchContext = new fetch_context_1.FetchContext(fetchEvent);\r\n        try {\r\n            yield delegate(fetchContext);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n        return fetchContext.response;\r\n    }))();\r\n}\r\nexports.add = {\r\n    activate: (handlers) => addExtendableEvent(\"activate\", handlers),\r\n    fetch: addFetchEvent,\r\n    install: (handlers) => addExtendableEvent(\"install\", handlers),\r\n    message: (handlers) => addExtendableEvent(\"message\", handlers),\r\n    notificationClick: (handlers) => addExtendableEvent(\"notificationclick\", handlers),\r\n    notificationClose: (handlers) => addExtendableEvent(\"notificationclose\", handlers),\r\n    push: (handlers) => addExtendableEvent(\"push\", handlers),\r\n    pushSubscriptionChange: (handlers) => addExtendableEvent(\"pushsubscriptionchange\", handlers),\r\n    sync: (handlers) => addExtendableEvent(\"sync\", handlers),\r\n};\r\nexports.eventListeners = {\r\n    extendableEvent: getExtendableEventListener,\r\n    fetchEvent: getFetchEventListener,\r\n};\r\nexports.eventHandlers = {\r\n    extendableEvent: getExtendableEventHandler,\r\n    fetchEvent: getFetchEventHandler,\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dvcmsvZGlzdC9idWlsZGVyLmpzP2Y1MjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCx3QkFBd0IsbUJBQU8sQ0FBQyxtRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N3b3JrL2Rpc3QvYnVpbGRlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZmV0Y2hfY29udGV4dF8xID0gcmVxdWlyZShcIi4vZmV0Y2gtY29udGV4dFwiKTtcclxuZnVuY3Rpb24gYWRkRXh0ZW5kYWJsZUV2ZW50KGV2ZW50VHlwZSwgaGFuZGxlcnMpIHtcclxuICAgIGlmIChoYW5kbGVycy5sZW5ndGgpIHtcclxuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBleHBvcnRzLmV2ZW50TGlzdGVuZXJzLmV4dGVuZGFibGVFdmVudChoYW5kbGVycykpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZEZldGNoRXZlbnQoZGVsZWdhdGUpIHtcclxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImZldGNoXCIsIGV4cG9ydHMuZXZlbnRMaXN0ZW5lcnMuZmV0Y2hFdmVudChkZWxlZ2F0ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldEV4dGVuZGFibGVFdmVudExpc3RlbmVyKGhhbmRsZXJzKSB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gZXhwb3J0cy5ldmVudEhhbmRsZXJzLmV4dGVuZGFibGVFdmVudChoYW5kbGVycyk7XHJcbiAgICByZXR1cm4gKGV2ZW50KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKGhhbmRsZXIoZXZlbnQpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZldGNoRXZlbnRMaXN0ZW5lcihkZWxlZ2F0ZSkge1xyXG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZldGNoRXZlbnQgPSBldmVudDtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gZXhwb3J0cy5ldmVudEhhbmRsZXJzLmZldGNoRXZlbnQoZGVsZWdhdGUsIGZldGNoRXZlbnQpO1xyXG4gICAgICAgIGZldGNoRXZlbnQud2FpdFVudGlsKGhhbmRsZXIpO1xyXG4gICAgICAgIGZldGNoRXZlbnQucmVzcG9uZFdpdGgoaGFuZGxlcik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldEV4dGVuZGFibGVFdmVudEhhbmRsZXIoaGFuZGxlcnMpIHtcclxuICAgIHJldHVybiAoZXZlbnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChoYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZldGNoRXZlbnRIYW5kbGVyKGRlbGVnYXRlLCBmZXRjaEV2ZW50KSB7XHJcbiAgICByZXR1cm4gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjb25zdCBmZXRjaENvbnRleHQgPSBuZXcgZmV0Y2hfY29udGV4dF8xLkZldGNoQ29udGV4dChmZXRjaEV2ZW50KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB5aWVsZCBkZWxlZ2F0ZShmZXRjaENvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmV0Y2hDb250ZXh0LnJlc3BvbnNlO1xyXG4gICAgfSkpKCk7XHJcbn1cclxuZXhwb3J0cy5hZGQgPSB7XHJcbiAgICBhY3RpdmF0ZTogKGhhbmRsZXJzKSA9PiBhZGRFeHRlbmRhYmxlRXZlbnQoXCJhY3RpdmF0ZVwiLCBoYW5kbGVycyksXHJcbiAgICBmZXRjaDogYWRkRmV0Y2hFdmVudCxcclxuICAgIGluc3RhbGw6IChoYW5kbGVycykgPT4gYWRkRXh0ZW5kYWJsZUV2ZW50KFwiaW5zdGFsbFwiLCBoYW5kbGVycyksXHJcbiAgICBtZXNzYWdlOiAoaGFuZGxlcnMpID0+IGFkZEV4dGVuZGFibGVFdmVudChcIm1lc3NhZ2VcIiwgaGFuZGxlcnMpLFxyXG4gICAgbm90aWZpY2F0aW9uQ2xpY2s6IChoYW5kbGVycykgPT4gYWRkRXh0ZW5kYWJsZUV2ZW50KFwibm90aWZpY2F0aW9uY2xpY2tcIiwgaGFuZGxlcnMpLFxyXG4gICAgbm90aWZpY2F0aW9uQ2xvc2U6IChoYW5kbGVycykgPT4gYWRkRXh0ZW5kYWJsZUV2ZW50KFwibm90aWZpY2F0aW9uY2xvc2VcIiwgaGFuZGxlcnMpLFxyXG4gICAgcHVzaDogKGhhbmRsZXJzKSA9PiBhZGRFeHRlbmRhYmxlRXZlbnQoXCJwdXNoXCIsIGhhbmRsZXJzKSxcclxuICAgIHB1c2hTdWJzY3JpcHRpb25DaGFuZ2U6IChoYW5kbGVycykgPT4gYWRkRXh0ZW5kYWJsZUV2ZW50KFwicHVzaHN1YnNjcmlwdGlvbmNoYW5nZVwiLCBoYW5kbGVycyksXHJcbiAgICBzeW5jOiAoaGFuZGxlcnMpID0+IGFkZEV4dGVuZGFibGVFdmVudChcInN5bmNcIiwgaGFuZGxlcnMpLFxyXG59O1xyXG5leHBvcnRzLmV2ZW50TGlzdGVuZXJzID0ge1xyXG4gICAgZXh0ZW5kYWJsZUV2ZW50OiBnZXRFeHRlbmRhYmxlRXZlbnRMaXN0ZW5lcixcclxuICAgIGZldGNoRXZlbnQ6IGdldEZldGNoRXZlbnRMaXN0ZW5lcixcclxufTtcclxuZXhwb3J0cy5ldmVudEhhbmRsZXJzID0ge1xyXG4gICAgZXh0ZW5kYWJsZUV2ZW50OiBnZXRFeHRlbmRhYmxlRXZlbnRIYW5kbGVyLFxyXG4gICAgZmV0Y2hFdmVudDogZ2V0RmV0Y2hFdmVudEhhbmRsZXIsXHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/swork/dist/builder.js\n");

/***/ }),

/***/ "./node_modules/swork/dist/configuration.js":
/*!**************************************************!*\
  !*** ./node_modules/swork/dist/configuration.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.configuration = {\r\n    environment: \"production\",\r\n    origin: self.location ? self.location.origin : \"\",\r\n    version: \"1.0.0\",\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dvcmsvZGlzdC9jb25maWd1cmF0aW9uLmpzPzJkNTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N3b3JrL2Rpc3QvY29uZmlndXJhdGlvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuY29uZmlndXJhdGlvbiA9IHtcclxuICAgIGVudmlyb25tZW50OiBcInByb2R1Y3Rpb25cIixcclxuICAgIG9yaWdpbjogc2VsZi5sb2NhdGlvbiA/IHNlbGYubG9jYXRpb24ub3JpZ2luIDogXCJcIixcclxuICAgIHZlcnNpb246IFwiMS4wLjBcIixcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/swork/dist/configuration.js\n");

/***/ }),

/***/ "./node_modules/swork/dist/fetch-context.js":
/*!**************************************************!*\
  !*** ./node_modules/swork/dist/fetch-context.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass FetchContext {\r\n    constructor(event) {\r\n        this.event = event;\r\n        this.request = event.request;\r\n    }\r\n}\r\nexports.FetchContext = FetchContext;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dvcmsvZGlzdC9mZXRjaC1jb250ZXh0LmpzPzA5NmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zd29yay9kaXN0L2ZldGNoLWNvbnRleHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBGZXRjaENvbnRleHQge1xyXG4gICAgY29uc3RydWN0b3IoZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gZXZlbnQucmVxdWVzdDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZldGNoQ29udGV4dCA9IEZldGNoQ29udGV4dDtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/swork/dist/fetch-context.js\n");

/***/ }),

/***/ "./node_modules/swork/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/swork/dist/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst configuration_1 = __webpack_require__(/*! ./configuration */ \"./node_modules/swork/dist/configuration.js\");\r\nexports.configuration = configuration_1.configuration;\r\nconst fetch_context_1 = __webpack_require__(/*! ./fetch-context */ \"./node_modules/swork/dist/fetch-context.js\");\r\nexports.FetchContext = fetch_context_1.FetchContext;\r\nconst swork_1 = __webpack_require__(/*! ./swork */ \"./node_modules/swork/dist/swork.js\");\r\nexports.Swork = swork_1.Swork;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dvcmsvZGlzdC9pbmRleC5qcz8wMmFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsd0JBQXdCLG1CQUFPLENBQUMsbUVBQWlCO0FBQ2pEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsbUVBQWlCO0FBQ2pEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbURBQVM7QUFDakMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3dvcmsvZGlzdC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ3VyYXRpb25cIik7XHJcbmV4cG9ydHMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb25fMS5jb25maWd1cmF0aW9uO1xyXG5jb25zdCBmZXRjaF9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi9mZXRjaC1jb250ZXh0XCIpO1xyXG5leHBvcnRzLkZldGNoQ29udGV4dCA9IGZldGNoX2NvbnRleHRfMS5GZXRjaENvbnRleHQ7XHJcbmNvbnN0IHN3b3JrXzEgPSByZXF1aXJlKFwiLi9zd29ya1wiKTtcclxuZXhwb3J0cy5Td29yayA9IHN3b3JrXzEuU3dvcms7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/swork/dist/index.js\n");

/***/ }),

/***/ "./node_modules/swork/dist/swork.js":
/*!******************************************!*\
  !*** ./node_modules/swork/dist/swork.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst builder = __webpack_require__(/*! ./builder */ \"./node_modules/swork/dist/builder.js\");\r\nconst allEvents = [\"activate\", \"install\", \"message\", \"notificationclick\", \"notificationclose\", \"push\", \"pushsubscriptionchange\", \"sync\"];\r\n/**\r\n * A Swork application. Contains logic to create event handlers and\r\n * middleware pipeline for a fetch request.\r\n *\r\n * @export\r\n * @class Swork\r\n */\r\nclass Swork {\r\n    /**\r\n     * Creates an instance of Swork.\r\n     * @memberof Swork\r\n     */\r\n    constructor() {\r\n        this.middlewares = [];\r\n        this.eventHandlers = new Map();\r\n        allEvents.forEach((x) => {\r\n            this.eventHandlers.set(x, []);\r\n        });\r\n    }\r\n    /**\r\n     * Registers all event handlers with the associated event and\r\n     * attaches the middleware pipeline.\r\n     *\r\n     * @memberof Swork\r\n     */\r\n    listen() {\r\n        allEvents.forEach((x) => {\r\n            const handlers = this.eventHandlers.get(x);\r\n            switch (x) {\r\n                case \"activate\":\r\n                    builder.add.activate(handlers);\r\n                    break;\r\n                case \"install\":\r\n                    builder.add.install(handlers);\r\n                    break;\r\n                case \"message\":\r\n                    builder.add.message(handlers);\r\n                    break;\r\n                case \"notificationclick\":\r\n                    builder.add.notificationClick(handlers);\r\n                    break;\r\n                case \"notificationclose\":\r\n                    builder.add.notificationClose(handlers);\r\n                    break;\r\n                case \"push\":\r\n                    builder.add.push(handlers);\r\n                    break;\r\n                case \"pushsubscriptionchange\":\r\n                    builder.add.pushSubscriptionChange(handlers);\r\n                    break;\r\n                case \"sync\":\r\n                    builder.add.sync(handlers);\r\n                    break;\r\n            }\r\n        });\r\n        const delegate = this.build();\r\n        builder.add.fetch(delegate);\r\n    }\r\n    /**\r\n     * Adds a middleware to the fetch request pipeline\r\n     *\r\n     * @param {(...Array<(Swork | Middleware | Array<(Swork | Middleware)>)>)} params\r\n     * @returns {Swork}\r\n     * @memberof Swork\r\n     */\r\n    use(...params) {\r\n        params.forEach((param) => {\r\n            if (!Array.isArray(param)) {\r\n                param = [param];\r\n            }\r\n            param.forEach((p) => {\r\n                if (p instanceof Swork) {\r\n                    allEvents.forEach((x) => {\r\n                        Array.prototype.push.apply(this.eventHandlers.get(x), p.eventHandlers.get(x));\r\n                    });\r\n                    this.middlewares.push.apply(this.middlewares, p.middlewares);\r\n                }\r\n                else {\r\n                    this.middlewares.push(p);\r\n                }\r\n            });\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds an event handler for the provided event type.\r\n     *\r\n     * @param {EventType} event\r\n     * @param {(...Array<(event: any) => Promise<void> | void>)} handlers\r\n     * @memberof Swork\r\n     */\r\n    on(event, ...handlers) {\r\n        Array.prototype.push.apply(this.eventHandlers.get(event), handlers);\r\n    }\r\n    build() {\r\n        this.middlewares.push((context) => {\r\n            context.response = fetch(context.request);\r\n            return Promise.resolve();\r\n        });\r\n        return (context) => {\r\n            let index = -1;\r\n            const dispatch = (currentIndex) => {\r\n                if (currentIndex <= index) {\r\n                    return Promise.reject(new Error(\"next() called multiple times\"));\r\n                }\r\n                index = currentIndex;\r\n                const middleware = this.middlewares[currentIndex];\r\n                return Promise.resolve(middleware(context, dispatch.bind(null, currentIndex + 1)));\r\n            };\r\n            return dispatch(0);\r\n        };\r\n    }\r\n}\r\nexports.Swork = Swork;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3dvcmsvZGlzdC9zd29yay5qcz83MGEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUErRDtBQUM5RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsaURBQWlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3dvcmsvZGlzdC9zd29yay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGJ1aWxkZXIgPSByZXF1aXJlKFwiLi9idWlsZGVyXCIpO1xyXG5jb25zdCBhbGxFdmVudHMgPSBbXCJhY3RpdmF0ZVwiLCBcImluc3RhbGxcIiwgXCJtZXNzYWdlXCIsIFwibm90aWZpY2F0aW9uY2xpY2tcIiwgXCJub3RpZmljYXRpb25jbG9zZVwiLCBcInB1c2hcIiwgXCJwdXNoc3Vic2NyaXB0aW9uY2hhbmdlXCIsIFwic3luY1wiXTtcclxuLyoqXHJcbiAqIEEgU3dvcmsgYXBwbGljYXRpb24uIENvbnRhaW5zIGxvZ2ljIHRvIGNyZWF0ZSBldmVudCBoYW5kbGVycyBhbmRcclxuICogbWlkZGxld2FyZSBwaXBlbGluZSBmb3IgYSBmZXRjaCByZXF1ZXN0LlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBjbGFzcyBTd29ya1xyXG4gKi9cclxuY2xhc3MgU3dvcmsge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFN3b3JrLlxyXG4gICAgICogQG1lbWJlcm9mIFN3b3JrXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgYWxsRXZlbnRzLmZvckVhY2goKHgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnNldCh4LCBbXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhbGwgZXZlbnQgaGFuZGxlcnMgd2l0aCB0aGUgYXNzb2NpYXRlZCBldmVudCBhbmRcclxuICAgICAqIGF0dGFjaGVzIHRoZSBtaWRkbGV3YXJlIHBpcGVsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBTd29ya1xyXG4gICAgICovXHJcbiAgICBsaXN0ZW4oKSB7XHJcbiAgICAgICAgYWxsRXZlbnRzLmZvckVhY2goKHgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmV2ZW50SGFuZGxlcnMuZ2V0KHgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhY3RpdmF0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkLmFjdGl2YXRlKGhhbmRsZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnN0YWxsXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQuaW5zdGFsbChoYW5kbGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkLm1lc3NhZ2UoaGFuZGxlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vdGlmaWNhdGlvbmNsaWNrXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQubm90aWZpY2F0aW9uQ2xpY2soaGFuZGxlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vdGlmaWNhdGlvbmNsb3NlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQubm90aWZpY2F0aW9uQ2xvc2UoaGFuZGxlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInB1c2hcIjpcclxuICAgICAgICAgICAgICAgICAgICBidWlsZGVyLmFkZC5wdXNoKGhhbmRsZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJwdXNoc3Vic2NyaXB0aW9uY2hhbmdlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQucHVzaFN1YnNjcmlwdGlvbkNoYW5nZShoYW5kbGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic3luY1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkLnN5bmMoaGFuZGxlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSB0aGlzLmJ1aWxkKCk7XHJcbiAgICAgICAgYnVpbGRlci5hZGQuZmV0Y2goZGVsZWdhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbWlkZGxld2FyZSB0byB0aGUgZmV0Y2ggcmVxdWVzdCBwaXBlbGluZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KC4uLkFycmF5PChTd29yayB8IE1pZGRsZXdhcmUgfCBBcnJheTwoU3dvcmsgfCBNaWRkbGV3YXJlKT4pPil9IHBhcmFtc1xyXG4gICAgICogQHJldHVybnMge1N3b3JrfVxyXG4gICAgICogQG1lbWJlcm9mIFN3b3JrXHJcbiAgICAgKi9cclxuICAgIHVzZSguLi5wYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMuZm9yRWFjaCgocGFyYW0pID0+IHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW0gPSBbcGFyYW1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgU3dvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxFdmVudHMuZm9yRWFjaCgoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmV2ZW50SGFuZGxlcnMuZ2V0KHgpLCBwLmV2ZW50SGFuZGxlcnMuZ2V0KHgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2guYXBwbHkodGhpcy5taWRkbGV3YXJlcywgcC5taWRkbGV3YXJlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBwcm92aWRlZCBldmVudCB0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnRUeXBlfSBldmVudFxyXG4gICAgICogQHBhcmFtIHsoLi4uQXJyYXk8KGV2ZW50OiBhbnkpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkPil9IGhhbmRsZXJzXHJcbiAgICAgKiBAbWVtYmVyb2YgU3dvcmtcclxuICAgICAqL1xyXG4gICAgb24oZXZlbnQsIC4uLmhhbmRsZXJzKSB7XHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5ldmVudEhhbmRsZXJzLmdldChldmVudCksIGhhbmRsZXJzKTtcclxuICAgIH1cclxuICAgIGJ1aWxkKCkge1xyXG4gICAgICAgIHRoaXMubWlkZGxld2FyZXMucHVzaCgoY29udGV4dCkgPT4ge1xyXG4gICAgICAgICAgICBjb250ZXh0LnJlc3BvbnNlID0gZmV0Y2goY29udGV4dC5yZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoY3VycmVudEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4IDw9IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm5leHQoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXNcIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBjdXJyZW50SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGV3YXJlID0gdGhpcy5taWRkbGV3YXJlc1tjdXJyZW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtaWRkbGV3YXJlKGNvbnRleHQsIGRpc3BhdGNoLmJpbmQobnVsbCwgY3VycmVudEluZGV4ICsgMSkpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKDApO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Td29yayA9IFN3b3JrO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/swork/dist/swork.js\n");

/***/ }),

/***/ "./src/service.worker.js":
/*!*******************************!*\
  !*** ./src/service.worker.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var swork__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swork */ \"./node_modules/swork/dist/index.js\");\n/* harmony import */ var swork__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(swork__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var swork_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swork-router */ \"./node_modules/swork-router/dist/index.js\");\n/* harmony import */ var swork_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(swork_router__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var mustache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mustache */ \"./node_modules/mustache/mustache.js\");\n/* harmony import */ var mustache__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(mustache__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n// import nonexistent_chart_html from 'raw-loader!./charts/nonexistent-chart.html';\r\n// import chart_html from 'raw-loader!./charts/chart.html';\r\n\r\nconst app = new swork__WEBPACK_IMPORTED_MODULE_0__[\"Swork\"]();\r\nconst router = new swork_router__WEBPACK_IMPORTED_MODULE_1__[\"Router\"]({\r\n    prefix: \"/dist\"\r\n});\r\n\r\nconst repls = {};\r\nconst charts = {};\r\n\r\nfunction make_json_response(body, status){\r\n    status.headers = new Headers({\r\n        \"Content-Type\" : \"application/json\"\r\n    });\r\n    return new Response(JSON.stringify(body), status);\r\n}\r\n\r\nfunction make_html_response(body, status){\r\n    status.headers = new Headers({\r\n        \"Content-Type\" : \"text/html; charset=UTF-8\"\r\n    });\r\n    return new Response(body, status);\r\n}\r\n\r\nasync function get_owning_client(chart_name){\r\n    if(!(chart_name in charts)){\r\n        return undefined;\r\n    }\r\n    let owningClientId = charts[chart_name];\r\n    let owningClient = await self.clients.get(owningClientId);\r\n    if(!owningClient){\r\n        console.log(\"Undefiend owning client, deleting chart.\");\r\n        if(owningClientId in repls){\r\n            repls[owningClientId].close();\r\n            delete repls[owningClientId];\r\n        }\r\n        delete charts[chart_name];\r\n    }\r\n    return owningClient;\r\n}\r\n\r\nrouter.put(\"/api/charts/:name\", async (context) => {\r\n    let clientId = context.event.clientId;\r\n    let name = context.params.name;\r\n    let owningClient = await get_owning_client(name);\r\n    if(owningClient){\r\n        context.response = make_json_response({ \r\n                response : `Chart \"${name}\" already exists.`,\r\n                code : \"put-chart::failed::already-exists\",\r\n                same_repl_owns_chart : clientId === owningClient.id\r\n            }, \r\n            { status : 409,  statusText : \"Chart already exists\" }\r\n        );\r\n        return;\r\n    }\r\n    charts[name] = clientId;\r\n    context.response = make_json_response(\r\n        { response : `Created chart \"${name}\".`, code : \"put-chart::succeeded\" },\r\n        { status : 201,   statusText : \"Created chart.\" }\r\n    );\r\n});\r\n\r\n\r\nrouter.get(\"/api/charts/:name\", async (context) => {\r\n    let { name } = context.params;\r\n    let owningClient = await get_owning_client(name);\r\n    if(owningClient){\r\n        context.response = make_json_response(\r\n            { clientId : owningClient.id, code : \"get-chart::succeeded\" },\r\n            { status : 200, statusText : \"Found chart\" }\r\n        );\r\n        return;\r\n    }\r\n    context.response = make_json_response({ code : \"get-chart::failed::not-found\" }, {status : 404, statusText : \"Chart not found.\"});\r\n});\r\n\r\n\r\nrouter.get(\"/charts/:name\", async (context) => {\r\n    let { name } = context.params;\r\n    if(name.endsWith(\".js\")){\r\n        context.response = fetch(`/dist/charts/${name}`);\r\n        return;\r\n    }\r\n    let owningClient = await get_owning_client(name);\r\n    if(owningClient){\r\n        let chart_html = await (await fetch(\"charts/chart.html\")).text();\r\n        context.response = make_html_response(\r\n            mustache__WEBPACK_IMPORTED_MODULE_2___default.a.render(chart_html,\r\n                { clientId : owningClient.id, chart_name : name }),\r\n            { status : 200, statusText : \"Found chart\" }\r\n        );\r\n        return;\r\n    }\r\n    let nonexistent_chart_html = await (await fetch(\"charts/nonexistent-chart.html\")).text();\r\n    context.response = make_html_response(\r\n        mustache__WEBPACK_IMPORTED_MODULE_2___default.a.render(nonexistent_chart_html, { chart_name : name }), \r\n        {status : 200, statusText : \"Chart not found.\"}\r\n    );\r\n});\r\n\r\napp.on(\"message\", handleMessage)\r\n\r\napp.use(router.routes());\r\n \r\napp.listen();\r\n\r\nlet pyodideWorkers = {};\r\n\r\nfunction handleMessage(event){\r\n    console.log(\"service_worker:: received message from a client:\", event.data, event);\r\n    let message = event.data;\r\n    if(!message.cmd){\r\n        throw Error(\"Undefined command\")\r\n    }\r\n    if(!message.cmd in messageDispatch){\r\n        throw Error(\"Unknown command.\");\r\n    }\r\n    messageDispatch[message.cmd](event);\r\n}\r\n\r\nlet messageDispatch = {\r\n    pyodide_worker_channel : installPyodidePort,\r\n    subscribe_chart_display : passChartChannelToPyodide\r\n};\r\n\r\nfunction installPyodidePort(event){\r\n    let port = event.data.port;\r\n    console.log(`Service worker :: installing pyodide port :: id : ${event.source.id}`);\r\n    port.addEventListener(\"message\", handlePyodideMessage);\r\n    repls[event.source.id] = port;\r\n    port.start();\r\n}\r\n\r\nfunction handlePyodideMessage(event){\r\n    console.error(`Unexpected message from pyodide repl`, event.data, event);\r\n    throw Error(\"Unexpected message from pyodide repl:\", event.data);\r\n}\r\n\r\nasync function passChartChannelToPyodide(event){\r\n    let { port, chart_name } = event.data;\r\n    event.data.client_id = event.source.id;\r\n    let owningClient = await get_owning_client(chart_name);\r\n    console.log(`Owning client Id : ${owningClient.id}`);\r\n    let repl_port = repls[owningClient.id];\r\n    repl_port.postMessage(event.data, [port]);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZS53b3JrZXIuanM/ZWY3MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0QztBQUNOO0FBQ047QUFDaEM7QUFDQTs7QUFFQSxnQkFBZ0IsMkNBQUs7QUFDckIsbUJBQW1CLG1EQUFNO0FBQ3pCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEJBQThCLEtBQUssb0NBQW9DO0FBQ2hGLFNBQVM7QUFDVDtBQUNBLENBQUM7OztBQUdEO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNERBQTREO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDLEdBQUcsOENBQThDO0FBQ3BJLENBQUM7OztBQUdEO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBUTtBQUNwQixpQkFBaUIsZ0RBQWdEO0FBQ2pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBUSxpQ0FBaUMsb0JBQW9CO0FBQ3JFLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9zZXJ2aWNlLndvcmtlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN3b3JrLCBGZXRjaENvbnRleHQgfSBmcm9tIFwic3dvcmtcIjtcclxuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSBcInN3b3JrLXJvdXRlclwiO1xyXG5pbXBvcnQgTXVzdGFjaGUgZnJvbSBcIm11c3RhY2hlXCI7XHJcbi8vIGltcG9ydCBub25leGlzdGVudF9jaGFydF9odG1sIGZyb20gJ3Jhdy1sb2FkZXIhLi9jaGFydHMvbm9uZXhpc3RlbnQtY2hhcnQuaHRtbCc7XHJcbi8vIGltcG9ydCBjaGFydF9odG1sIGZyb20gJ3Jhdy1sb2FkZXIhLi9jaGFydHMvY2hhcnQuaHRtbCc7XHJcblxyXG5jb25zdCBhcHAgPSBuZXcgU3dvcmsoKTtcclxuY29uc3Qgcm91dGVyID0gbmV3IFJvdXRlcih7XHJcbiAgICBwcmVmaXg6IFwiL2Rpc3RcIlxyXG59KTtcclxuXHJcbmNvbnN0IHJlcGxzID0ge307XHJcbmNvbnN0IGNoYXJ0cyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gbWFrZV9qc29uX3Jlc3BvbnNlKGJvZHksIHN0YXR1cyl7XHJcbiAgICBzdGF0dXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCJcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShib2R5KSwgc3RhdHVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFrZV9odG1sX3Jlc3BvbnNlKGJvZHksIHN0YXR1cyl7XHJcbiAgICBzdGF0dXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcclxuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiIDogXCJ0ZXh0L2h0bWw7IGNoYXJzZXQ9VVRGLThcIlxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHN0YXR1cyk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldF9vd25pbmdfY2xpZW50KGNoYXJ0X25hbWUpe1xyXG4gICAgaWYoIShjaGFydF9uYW1lIGluIGNoYXJ0cykpe1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgb3duaW5nQ2xpZW50SWQgPSBjaGFydHNbY2hhcnRfbmFtZV07XHJcbiAgICBsZXQgb3duaW5nQ2xpZW50ID0gYXdhaXQgc2VsZi5jbGllbnRzLmdldChvd25pbmdDbGllbnRJZCk7XHJcbiAgICBpZighb3duaW5nQ2xpZW50KXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlVuZGVmaWVuZCBvd25pbmcgY2xpZW50LCBkZWxldGluZyBjaGFydC5cIik7XHJcbiAgICAgICAgaWYob3duaW5nQ2xpZW50SWQgaW4gcmVwbHMpe1xyXG4gICAgICAgICAgICByZXBsc1tvd25pbmdDbGllbnRJZF0uY2xvc2UoKTtcclxuICAgICAgICAgICAgZGVsZXRlIHJlcGxzW293bmluZ0NsaWVudElkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGNoYXJ0c1tjaGFydF9uYW1lXTtcclxuICAgIH1cclxuICAgIHJldHVybiBvd25pbmdDbGllbnQ7XHJcbn1cclxuXHJcbnJvdXRlci5wdXQoXCIvYXBpL2NoYXJ0cy86bmFtZVwiLCBhc3luYyAoY29udGV4dCkgPT4ge1xyXG4gICAgbGV0IGNsaWVudElkID0gY29udGV4dC5ldmVudC5jbGllbnRJZDtcclxuICAgIGxldCBuYW1lID0gY29udGV4dC5wYXJhbXMubmFtZTtcclxuICAgIGxldCBvd25pbmdDbGllbnQgPSBhd2FpdCBnZXRfb3duaW5nX2NsaWVudChuYW1lKTtcclxuICAgIGlmKG93bmluZ0NsaWVudCl7XHJcbiAgICAgICAgY29udGV4dC5yZXNwb25zZSA9IG1ha2VfanNvbl9yZXNwb25zZSh7IFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgOiBgQ2hhcnQgXCIke25hbWV9XCIgYWxyZWFkeSBleGlzdHMuYCxcclxuICAgICAgICAgICAgICAgIGNvZGUgOiBcInB1dC1jaGFydDo6ZmFpbGVkOjphbHJlYWR5LWV4aXN0c1wiLFxyXG4gICAgICAgICAgICAgICAgc2FtZV9yZXBsX293bnNfY2hhcnQgOiBjbGllbnRJZCA9PT0gb3duaW5nQ2xpZW50LmlkXHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICB7IHN0YXR1cyA6IDQwOSwgIHN0YXR1c1RleHQgOiBcIkNoYXJ0IGFscmVhZHkgZXhpc3RzXCIgfVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY2hhcnRzW25hbWVdID0gY2xpZW50SWQ7XHJcbiAgICBjb250ZXh0LnJlc3BvbnNlID0gbWFrZV9qc29uX3Jlc3BvbnNlKFxyXG4gICAgICAgIHsgcmVzcG9uc2UgOiBgQ3JlYXRlZCBjaGFydCBcIiR7bmFtZX1cIi5gLCBjb2RlIDogXCJwdXQtY2hhcnQ6OnN1Y2NlZWRlZFwiIH0sXHJcbiAgICAgICAgeyBzdGF0dXMgOiAyMDEsICAgc3RhdHVzVGV4dCA6IFwiQ3JlYXRlZCBjaGFydC5cIiB9XHJcbiAgICApO1xyXG59KTtcclxuXHJcblxyXG5yb3V0ZXIuZ2V0KFwiL2FwaS9jaGFydHMvOm5hbWVcIiwgYXN5bmMgKGNvbnRleHQpID0+IHtcclxuICAgIGxldCB7IG5hbWUgfSA9IGNvbnRleHQucGFyYW1zO1xyXG4gICAgbGV0IG93bmluZ0NsaWVudCA9IGF3YWl0IGdldF9vd25pbmdfY2xpZW50KG5hbWUpO1xyXG4gICAgaWYob3duaW5nQ2xpZW50KXtcclxuICAgICAgICBjb250ZXh0LnJlc3BvbnNlID0gbWFrZV9qc29uX3Jlc3BvbnNlKFxyXG4gICAgICAgICAgICB7IGNsaWVudElkIDogb3duaW5nQ2xpZW50LmlkLCBjb2RlIDogXCJnZXQtY2hhcnQ6OnN1Y2NlZWRlZFwiIH0sXHJcbiAgICAgICAgICAgIHsgc3RhdHVzIDogMjAwLCBzdGF0dXNUZXh0IDogXCJGb3VuZCBjaGFydFwiIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnRleHQucmVzcG9uc2UgPSBtYWtlX2pzb25fcmVzcG9uc2UoeyBjb2RlIDogXCJnZXQtY2hhcnQ6OmZhaWxlZDo6bm90LWZvdW5kXCIgfSwge3N0YXR1cyA6IDQwNCwgc3RhdHVzVGV4dCA6IFwiQ2hhcnQgbm90IGZvdW5kLlwifSk7XHJcbn0pO1xyXG5cclxuXHJcbnJvdXRlci5nZXQoXCIvY2hhcnRzLzpuYW1lXCIsIGFzeW5jIChjb250ZXh0KSA9PiB7XHJcbiAgICBsZXQgeyBuYW1lIH0gPSBjb250ZXh0LnBhcmFtcztcclxuICAgIGlmKG5hbWUuZW5kc1dpdGgoXCIuanNcIikpe1xyXG4gICAgICAgIGNvbnRleHQucmVzcG9uc2UgPSBmZXRjaChgL2Rpc3QvY2hhcnRzLyR7bmFtZX1gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgb3duaW5nQ2xpZW50ID0gYXdhaXQgZ2V0X293bmluZ19jbGllbnQobmFtZSk7XHJcbiAgICBpZihvd25pbmdDbGllbnQpe1xyXG4gICAgICAgIGxldCBjaGFydF9odG1sID0gYXdhaXQgKGF3YWl0IGZldGNoKFwiY2hhcnRzL2NoYXJ0Lmh0bWxcIikpLnRleHQoKTtcclxuICAgICAgICBjb250ZXh0LnJlc3BvbnNlID0gbWFrZV9odG1sX3Jlc3BvbnNlKFxyXG4gICAgICAgICAgICBNdXN0YWNoZS5yZW5kZXIoY2hhcnRfaHRtbCxcclxuICAgICAgICAgICAgICAgIHsgY2xpZW50SWQgOiBvd25pbmdDbGllbnQuaWQsIGNoYXJ0X25hbWUgOiBuYW1lIH0pLFxyXG4gICAgICAgICAgICB7IHN0YXR1cyA6IDIwMCwgc3RhdHVzVGV4dCA6IFwiRm91bmQgY2hhcnRcIiB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbm9uZXhpc3RlbnRfY2hhcnRfaHRtbCA9IGF3YWl0IChhd2FpdCBmZXRjaChcImNoYXJ0cy9ub25leGlzdGVudC1jaGFydC5odG1sXCIpKS50ZXh0KCk7XHJcbiAgICBjb250ZXh0LnJlc3BvbnNlID0gbWFrZV9odG1sX3Jlc3BvbnNlKFxyXG4gICAgICAgIE11c3RhY2hlLnJlbmRlcihub25leGlzdGVudF9jaGFydF9odG1sLCB7IGNoYXJ0X25hbWUgOiBuYW1lIH0pLCBcclxuICAgICAgICB7c3RhdHVzIDogMjAwLCBzdGF0dXNUZXh0IDogXCJDaGFydCBub3QgZm91bmQuXCJ9XHJcbiAgICApO1xyXG59KTtcclxuXHJcbmFwcC5vbihcIm1lc3NhZ2VcIiwgaGFuZGxlTWVzc2FnZSlcclxuXHJcbmFwcC51c2Uocm91dGVyLnJvdXRlcygpKTtcclxuIFxyXG5hcHAubGlzdGVuKCk7XHJcblxyXG5sZXQgcHlvZGlkZVdvcmtlcnMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpe1xyXG4gICAgY29uc29sZS5sb2coXCJzZXJ2aWNlX3dvcmtlcjo6IHJlY2VpdmVkIG1lc3NhZ2UgZnJvbSBhIGNsaWVudDpcIiwgZXZlbnQuZGF0YSwgZXZlbnQpO1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBldmVudC5kYXRhO1xyXG4gICAgaWYoIW1lc3NhZ2UuY21kKXtcclxuICAgICAgICB0aHJvdyBFcnJvcihcIlVuZGVmaW5lZCBjb21tYW5kXCIpXHJcbiAgICB9XHJcbiAgICBpZighbWVzc2FnZS5jbWQgaW4gbWVzc2FnZURpc3BhdGNoKXtcclxuICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gY29tbWFuZC5cIik7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlRGlzcGF0Y2hbbWVzc2FnZS5jbWRdKGV2ZW50KTtcclxufVxyXG5cclxubGV0IG1lc3NhZ2VEaXNwYXRjaCA9IHtcclxuICAgIHB5b2RpZGVfd29ya2VyX2NoYW5uZWwgOiBpbnN0YWxsUHlvZGlkZVBvcnQsXHJcbiAgICBzdWJzY3JpYmVfY2hhcnRfZGlzcGxheSA6IHBhc3NDaGFydENoYW5uZWxUb1B5b2RpZGVcclxufTtcclxuXHJcbmZ1bmN0aW9uIGluc3RhbGxQeW9kaWRlUG9ydChldmVudCl7XHJcbiAgICBsZXQgcG9ydCA9IGV2ZW50LmRhdGEucG9ydDtcclxuICAgIGNvbnNvbGUubG9nKGBTZXJ2aWNlIHdvcmtlciA6OiBpbnN0YWxsaW5nIHB5b2RpZGUgcG9ydCA6OiBpZCA6ICR7ZXZlbnQuc291cmNlLmlkfWApO1xyXG4gICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVQeW9kaWRlTWVzc2FnZSk7XHJcbiAgICByZXBsc1tldmVudC5zb3VyY2UuaWRdID0gcG9ydDtcclxuICAgIHBvcnQuc3RhcnQoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlUHlvZGlkZU1lc3NhZ2UoZXZlbnQpe1xyXG4gICAgY29uc29sZS5lcnJvcihgVW5leHBlY3RlZCBtZXNzYWdlIGZyb20gcHlvZGlkZSByZXBsYCwgZXZlbnQuZGF0YSwgZXZlbnQpO1xyXG4gICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIG1lc3NhZ2UgZnJvbSBweW9kaWRlIHJlcGw6XCIsIGV2ZW50LmRhdGEpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBwYXNzQ2hhcnRDaGFubmVsVG9QeW9kaWRlKGV2ZW50KXtcclxuICAgIGxldCB7IHBvcnQsIGNoYXJ0X25hbWUgfSA9IGV2ZW50LmRhdGE7XHJcbiAgICBldmVudC5kYXRhLmNsaWVudF9pZCA9IGV2ZW50LnNvdXJjZS5pZDtcclxuICAgIGxldCBvd25pbmdDbGllbnQgPSBhd2FpdCBnZXRfb3duaW5nX2NsaWVudChjaGFydF9uYW1lKTtcclxuICAgIGNvbnNvbGUubG9nKGBPd25pbmcgY2xpZW50IElkIDogJHtvd25pbmdDbGllbnQuaWR9YCk7XHJcbiAgICBsZXQgcmVwbF9wb3J0ID0gcmVwbHNbb3duaW5nQ2xpZW50LmlkXTtcclxuICAgIHJlcGxfcG9ydC5wb3N0TWVzc2FnZShldmVudC5kYXRhLCBbcG9ydF0pO1xyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/service.worker.js\n");

/***/ })

/******/ });